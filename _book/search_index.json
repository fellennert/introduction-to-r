[["index.html", "An(other) introduction to R Chapter 1 Prologue 1.1 Course outline 1.2 Why R 1.3 Further links 1.4 Last but not least", " An(other) introduction to R Felix Lennert 2021-08-24 Chapter 1 Prologue Dear student, in the following, you will receive a gentle introduction to R and how you can use it to work with data. This tutorial was heavily inspired by Richard Cotton’s “Learning R” (Cotton 2013) and Hadley Wickham’s and Garrett Grolemund’s “R for Data Science” (abbreviated with R4DS). The latter can be found online (Wickham and Grolemund 2016). We will not immediately start out with the packages from the tidyverse (although some strong points have been made in favor of doing so right from the start). I will rather try to build some sort of foundation from where we can proceed to the tidy packages in the following lessons. Hence, one can also understand this tutorial as an introduction to the tidyverse (Wickham, Averick, et al. 2019) (or hadleyverse, as it was named originally), even though I will not introduce it in this very first part. When it comes to what I would refer to as the “daily workflow” with R and RStudio, Jennifer Bryan’s blog articles have been a big inspiration for me. When looking at RMarkdown, I will mainly build on “R Markdown: The Definitive Guide” – which is also freely available online (Xie, Allaire, and Grolemund 2018). Note that you will find all of the chapters as executable RMarkdown documents (on which you will learn more in the following chapter) in the dedicated GitHub repository. Moreover, I will record videos for each chapter and embed them in this online script, just like this: 1.1 Course outline The coming course will be structured as follows: In the beginning, Chapter 2, I will introduce you to R and the Integrated Developer Environment (IDE) RStudio. Thereafter, in Chapter 3, the basic principles of R (such as underlying principles and data types) are taught. The process of performing data science looks like this: Data science as a process, taken from Wickham and Grolemund (2016) Chapter 4 will be when you do your first steps with data. In order to analyze them, data need to be read in. Then, more often than not, they need to be reshaped properly to become tidy. Therefore, first, the theoretical principles of tidy data need to be clarified. Those data sets need to be prepared for subsequent analyses – they need to become tidy. You are introduced to techniques for achieving this. Moreover, certain analyses require transformed variables. Chapter 5 teaches you how to further manipulate variables and data sets in general. Chapter 6 will demonstrate how you can work with strings. In order to achieve this, a general introduction to regular expressions (regexes) is provided. Chapter 7 will demonstrate how to work with categorical data. In this course, modeling will not be on the menu. This will, however, be covered in further depth in courses on statistical inference. Hence, the script will proceed with communicating data. Chapter 8 will show you how to properly summarize descriptives. In a similar vein, visualization with ggplot2 is to be covered in Chapter 9. Finally, you need to be able to communicate your results properly. This encompasses exporting tables and visualization. However, you can also write entire papers in R using RMarkdown. This is to be exemplified in Chapter 10. While data science with R is comparably simple and at least 80 per cent of the tasks you will face can be accomplished by just using the tools introduced in chapters 2–9, you might want to delve a bit deeper into the programming part of R. Initial guidance will be provided in Chapter 11 Some sessions will be longer and are split up into multiple, more digestible chunks. Each chapter will come with exercises that you can do at home. Those are not mandatory, yet it is highly advisable to do them thoroughly. [add link to exercise script] It is worth noting that this script is by no means exhaustive. There are a multitude of ways (and packages) you can use R. I personally go with the “tidy” way of using it as this family of packages is conclusive and has increasingly taken over the R market. However, if you find other approaches of using R to resonate better with you, then no worries; I am quite agnostic to those paradigms and strongly encourage you to choose the way of using R that floats your own boat best. 1.2 Why R You may wonder why it makes sense for you to learn R and there are many people with way brighter minds and better ways with words than I who have thought and written about this topic. I will just briefly dwell upon the points that I find most interesting from a research perspective (I consider myself a computational social scientist) and then link to resources which might point out how R can contribute to your research/carreer development/pursuit of happiness/you name it depending on your background and your goals. 1.2.1 Reproducibility In science, we are facing what has been famously coined the “replication crisis”. One way to overcome it is maximum transparency (Munafò et al. 2017). Here, R can help transparency as researchers can simply publish their code to make it easy for their colleagues to comprehend what sorts of analyses have exactly been performed. Moreover, publishing (R) code decisively facilitates replicating the actual analyses with different data to assess the transportability and generalizability of the results. 1.2.2 It’s free and community-based While licences for applications such as Stata and IBM SPSS are costly for schools and companies, R comes at no cost1. Moreover, the useRs (how R users call themselves) community is constantly developing further packages to extend Rs functionality for free. Also, you can write your own packages or functions if you want to extend your R’s functionality – and then publish them to contribute to the community. Hence, there will not be any need to pay for an R extension or update ever. 1.2.3 Jobs Data scientist has been considered the “sexiest job of the 21st century” and one of their sharpest tools in the shed is R. The following graphs stem from a blog entry by the statistician Robert Muenchen. Moreover, the demand for R has been constantly growing throughout the last couple of years. Note that stuff such as Tensorflow and Keras are also implemented in R, so R definitely will give you an edge on the job market. And also if your goal is to stay in academia, the tendency appears to be clear: 1.3 Further links Each chapter will contain a Further links section, where I include useful online resources which you can consume to delve deeper into the matters discussed in the respective chapter. Not convinced yet? If you strive for a carreer in business analytics, let this article sink in. If you worry about R being too complex as you’re no computer scientist, read here. From an academia point of view, R is very likely to entirely take over the, at least, social sciences and you will be very likely to encounter it in the future. 1.4 Last but not least Learning R – and programming in general – is tough. More often than not, things will not go the way you want them to go. Mostly, this is due to minor typos or the fact that R is case-sensitive. However, don’t fret. Only practice makes perfekt. It is perfectly normal to not comprehend error messages. The following video illustrates this:{r echo=FALSE} vembedr::embed_youtube(\"HluANRwPyNo\") If questions arise that a google search cannot answer, I am always only one email away – and will probably just hit google right away, too, to figure something out for you. References "],["introrstudio.html", "Chapter 2 Getting started with RStudio 2.1 Installing R 2.2 Installing RStudio 2.3 Setting up RStudio 2.4 Some remarks on your daily workflow 2.5 R scripts and RMarkdown 2.6 Further links", " Chapter 2 Getting started with RStudio 2.1 Installing R For downloading R, just visit the website of the Comprehensive R Archive Network (CRAN). CRAN is simply a network of ftp and web servers all around the world. Here, things related to R (code, documentation, etc.) are stored and can be downloaded. On top of the page, you will find a box with three links that refer to different versions depending on your operating system. Choose the one that applies. The CRAN webpage – choose the right operating system Thereafter, just click the link for downloading the latest version (we will work with R 4.1.0). If you are on a Mac (as I am), it will look like this: The CRAN webpage – download the latest version After the download is finished, just execute the installer and, once it is done, you can proceed with the installation of RStudio. New versions of R are released multiple times per year. If you want to update your R, the process is the same as installing it from scratch: go to https://cran.r-project.org, download the latest version, install it, and that is basically it. 2.2 Installing RStudio When you are on a Windows or Mac machine and you click the R icon, a window (the so-called Mac or Windows GUI – graphic user interface) that looks pretty much like your machine’s terminal will appear. You could now just type R code in there and execute it – and, in fact, that is how the users did it the ancient way. In my opinion, this is fairly inconvenient. Luckily, we have progressed a lot from that and come up with IDEs (integrated development environments) for R. The most popular among them is RStudio which we will use as well. To install RStudio, just click on this link, choose the right version (i.e., RStudio Desktop – Open Source License), and hit the download button. After downloading it, you simply install it, and then you are good to go. 2.3 Setting up RStudio After installing RStudio, you can open it just like every other application on your machine. When you open it for the very first time, a window will appear that looks like this: RStudio; obtained from Grolemund (2014) As you can see, there are three panes. When you open a script (for instance, by clicking File &gt;&gt; New File &gt;&gt; R Script), a fourth one will appear in the upper part on the left side. If you open multiple scripts, they will be organized in tabs as well. Every pane contains different things: By default, the console can be found in the lower left pane. This is basically how the GUI would look like. You can either manually enter commands, and execute them by pressing return, or write code in the script (upper left pane), and run it by either clicking “Run” or hitting cmd/ctrl+return (Mac/Windows). Then, the console will show, (1), the code you ran and, (2), depending on what you executed, the output. In the upper right pane, there are two tabs: the environment and the history. The former will show you all the objects you have defined, the latter all the commands you have executed. The lower left pane now consists of four tabs: “Files” simply shows you the files that are stored in the working direction you are in. “Plots” is only used if you have plotted something – and is then called automatically, so you will probably never click on it. In “Packages,” as the name hints on, all the packages that are installed are listed. In theory, you could call them from there as well – but I strongly recommend not to. And finally, the “Help” tab provides you with documentations of packages etc. This sounds handy, but I hardly use it – simple googling or calling the ?[name_of_function] has worked out best for me so far. In the following, I will tell you more about what has appeared to work best FOR ME: Disclaimer: Every useR has their own preferences when it comes to their setup. Hence, you should see the following paragraphs only as recommendations that originate from my experience. As you may have noticed, there are a lot of different things RStudio provides you with. However, in every-day use, you will mostly use these five: the script you are actually working on. The console for seeing what your code has produced. The environment for a quick overview of the objects you are actually working with. The “Files” section for seeing the files in your working directory (this is where R projects will come in extremely handy). The “Plots” section for seeing your visualizations. As the latter opens by itself as soon as you plot something, I mainly use the former four. However, if you use RStudio projects – as you definitely should – you will only occasionally need the “Files” section. Furthermore, your screen is wider than it is high. Hence, vertical space is scarcer than horizontal. At the heart of your coding lies your script, you should therefore give it the utmost space possible. On the right then there is space for two panes you will always have to give quick glimpses: the console and the environment. I put the former to the bottom and the latter on top. When the “Plots” section opens up, you will manually have to return to your former tab. Therefore, I put it to the lower left side where it does not bother me and I can minimize it with one click when I do not need it anymore. My RStudio layout looks like this: my RStudio layout How you accomplish this? Preferences &gt;&gt; Pane Layout. Other strongly recommended settings (ordered by Options section): General: Never save your work space, this makes you lazy (read more here) Code: some “Display” settings make your life easier; also set default encoding to UTF-8 in the “Save” section Appearance: check out some themes (I use: RStudio theme “Modern,” Editor font “Courier,” Font size 11, and Editor theme “Cobalt”) Panes layout: feel free to set them up the way I did More inspiration can be found here. 2.4 Some remarks on your daily workflow As some of you are beginners, it might be hard for you to see the point in setting up projects already. The intermediate and advanced users among you, who are not familiar with projects yet though, might also wonder what they would need it for: working with R has gone pretty well in the past, so why should you change this running system? I start out making points on why using Projects is useful. Then, I will provide step-by-step guidance on how to set them up. Since using GitHub is not that straight-forward, I will motivate why to use it and then link to a bigger tutorial covering the setup process (again by Jennifer Bryan, a statistic professor who also works at RStudio). 2.4.1 RStudio Projects 2.4.1.1 Motivation Disclaimer: those things might not be entirely clear right away. However, I am deeply convinced that it is important that you use R and RStudio properly from the start. Otherwise it won’t be as easy to re-build the right habits. If you analyze data with R, one of the first things you do is to load in the data that you want to perform your analyses on. Then, you perform your analyses on them, and save the results in the (probably) same directory. When you load a data set into R, you might use the readr package and do read_csv(absolute_file_path.csv). This becomes fairly painful if you need to read in more than one data set. Then, relative paths (i.e., where you start from a certain point in your file structure, e.g., your file folder) become more useful. How you CAN go across this is to use the setwd(absolute_file_path_to_your_directory) function. Here, set stands for set and wd stands for working directory. If you are not sure about what the current working directory actually is, you can use getwd() which is the equivalent to setwd(file_path). This enables you to read in a data set – if the file is in the working directory – by only using read_csv(file_name.csv). However, if you have ever worked on an R project with other people in a group and exchanged scripts regularly, you may have encountered one of the big problems with this setwd(file_path) approach: as it only takes absolute paths like this one: “/Users/felixlennert/Library/Mobile Documents/comappleCloudDocs/phd/teaching/hhs-stockholm/fall2021/scripts/,” no other person will be able to run this script without making any changes2. Just to be clear: there are no two machines which have the exact same file structure. This is where RStudio Projects come into play: they make every file path relative. The Project file (ends with .Rproj) basically sets the working directory to the folder it is in. Hence, if you want to send your work to a peer or a teacher, just send a folder which also contains the .Rproj file and they will be able to work on your project without the hassle of pasting file paths into setwd() commands. 2.4.1.2 How to create an RStudio Project? I strongly suggest that you set up a project which is dedicated to this course. In RStudio, click File &gt;&gt; New Project… A windows pops up which lets you select between “New Directory,” “Existing Directory,” and “Version Control.” The first option creates a new folder which is named after your project, the second one “associates a project with an existing working directory,” and the third one only applies to version control (like, for instance, GitHub) users. I suggest that you click “New Directory.” Now you need to specify the type of the project (Empty project, R package, or Shiny Web Application). In our case, you will need a “new project.” Hit it! The final step is to choose the folder the project will live in. If you have already created a folder which is dedicated to this course, choose this one, and let the project live in there as a sub-directory. When you write code for our course in the future, you first open the R project – by double-clicking the .Rproj file – and then create either a new script or open a former one (e.g., by going through the “Files” tab in the respective pane which will show the right directory already.) 2.5 R scripts and RMarkdown In this course, you will work with two sorts of documents to store your code in: R scripts (suffix .R) and RMarkdown documents (suffix .Rmd). In the following, I will briefly introduce you to both of them. 2.5.1 R scripts The console, where you can only execute your code, is great for experimenting with R. If you want to store it – e.g., for sharing – you need something different. This is where R scripts come in handy. When you are in RStudio, you create a new script by either clicking File &gt;&gt; New File &gt;&gt; R Script or ctrl/cmd+shift+n. There are multiple ways to run code in the script: cmd/ctrl+return (Mac/Windows) – execute entire expression and jump to next line option/alt+return (Mac/Windows) – execute entire expression and remain in line cmd/ctrl+shift+return (Mac/Windows) – execute entire script from the beginning to the end (rule: every script you hand in or send to somebody else should run smoothly from the beginning to the end) If you want to make annotations to your code (which you should do because it makes everything easier to read and understand), just insert ‘#’ into your code. Every expression that stands to the right of the ‘#’ sign will not be executed when you run the code. 2.5.2 RMarkdown A time will come where you will not just do analyses for yourself in R, but you will also have to communicate them. Let’s take a master’s thesis as an example: you need a type of document that is able to encapsulate: text (properly formatted), visualizations (tables, graphs, maybe images), and references. An RMarkdown document can do it all, plus, your entire analysis can live in there as well. So there is no need anymore for the cumbersome process of copying data from MS Excel or IBM SPSS into an MS Word table. You just tell RMarkdown what it should communicate and what not. In the following, I will not provide you with an exhaustive introduction to RMarkdown. Instead, I will focus on getting you started and then referring you to better, more exhaustive resources. It is not that I am too lazy to write a big tutorial, but there are state-of-the-art tutorials and resources (which mainly come straight from people who work on the forefront of the development of these tools) which are available for free. By linking to them, I want to encourage you to get involved and dig into this stuff. So, let’s get you started! You create an RMarkdown file by clicking File &gt;&gt; New File &gt;&gt; R Markdown…. Then, a window pops up that looks like this: New RMarkdown Note that you could also do a presentation (with the beamer package), a shiny app, or use templates. We will focus on simple RMarkdown documents3. Here, you can type in a title, the name(s) of the author(s), and choose the default output format. For now you have to choose one, but later you can switch to one of the others whenever you want to. HTML is handy for lightweight, quickly knitted files, or if you want to publish it on a website. PDF is good if you are experienced with \\(\\LaTeX\\) and want to further modify it in terms of formatting etc., or simply want to get a more formally looking document (I use it if I need to hand in something that is supposed to be graded). If you want to knit to PDF, you need a running \\(\\LaTeX\\) version on your machine. If you do not have one, I recommend you to install tinytex. I linked installation instructions down below. Word puts out an MS Word document – especially handy if you collaborate with people who are either not experienced in R, like older faculty, or want some parts to be proof-read (remember the Track-Changes function?). Note that you need to have MS Word or LibreOffice installed on your machine. Did you notice the term “knit?” The logic behind RMarkdown documents is that you edit them in RStudio and then “knit” them. This means that it calls the knitr package. Thereby, all the code you include into the document is executed from scratch. If the code does not work and throws an error, the document will not knit – hence, it needs to be properly written to avoid head-scratching. The knitr package creates a markdown file (suffix: .md). This is then processed by pandoc, a universal document converter. The big advantage of this two-step approach is that it enables a wide range of output formats. For your first RMarkdown document, choose HTML and click “OK.” Then, you see a new plain-text file which looks like this: A fresh and clean RMarkdown document In the top section, surrounded by ---, you can see the so-called YAML header (or YAML metadata, or YAML frontmatter – check out Wikipedia for more information on it). YAML stands for “YAML Ain’t Markup Language” and it is a human-readable data-serialization language. Quick heads-up: indentation matters in your YAML header. This is the metadata of your document. In this minimalistic example, the title, the author, the date, and the desired output are specified (as you specified them when you created the new document). Hence, you can always change them. After the YAML header, there comes a code chunk. Code chunks start with ```{r} and end with ```. Inside the code chunk, you can write R code which can be executed by either clicking the green “Play” button or by using the same keyboard shortcuts as in scripts. There are several chunk options available: either click on the sprocket or check them out online and include them in the chunk’s header (like this: ```{r include=FALSE}). Beyond that, you can (and should) name your chunks. This makes it easier to find the flawed ones when your document fails to knit. This is done by simply including the name into the title like this: ```{r cars}. Find more on chunk options here. The double hashes imply that “R Markdown” is a header. In the text, there are examples on how to include links (“&lt;&gt;”), how to make text bold (double asterixes), etc. For more information on how to format plain text in an RMarkdown document, check out the RMarkdown cheatsheet and Reference guide. 2.6 Further links If you require a more extensive description of how to install R and RStudio, click here: Hands-on Programming with R – Appendix A, a book by one of the co-authors of R for Data Science. If you are already more advanced, you can read more useful stuff on using R and RStudio by two RStudio employees: What they forgot to teach you about R Hadley Wickham and Garrett Grolemund wrote an entire chapter in R4DS on scripts – and on RMarkdown. Yihui Xie, J. J. Allaire, and Garrett Grolemund wrote what they call “R Markdown: The Definitive Guide.” It is freely available online. An introduction to RMarkdown from RStudio can be found here. Yihui Xie published a manual for installing the tinytex package. If you want to write academic papers using RMarkdown, you need to be able to include references properly. When I decided to do so, I found it sort of complicated. However, I stuck to this tutorial and since then it has worked like a charm. More on this in Session #8. GitHub might make your daily life and your shared projects decisively easier, especially in connection with RMarkdown. Find an illustration of its potential in this vide. References "],["intror.html", "Chapter 3 Intro to R 3.1 Installing packages 3.2 Basic arithmetic operations 3.3 Vectors 3.4 Further links", " Chapter 3 Intro to R I can recall vividly how I started learning R as an undergrad and I told a friend of mine – a then grad student in education science and SPSS user – about it. He replied: “R? Isn’t that this incredibly fancy scientific calculator?” Well, he was not exactly right – but not really wrong either. Today, you are going to make your first steps with R. In the following, you will learn how to use R as a fancy calculator. This encompasses that you can extend its functionality by installing packages, the possibility to do all kinds of calculations, storing data in objects of several kinds, and accessing them. 3.1 Installing packages Being a fancy calculator implies that you can extend it as you want. One of the big upsides of using R is that due to its active community, whose members are permanently striving to make it a bit better, we useRs are basically standing on the shoulders of giants. You can install packages from CRAN by using the install.packages() command. #install.packages(&quot;tidyverse&quot;) # installs the tidyverse package # insert &#39;#&#39; if you want R not to execute the things that stand to its right; pretty useful for annotating code CRAN packages have to fulfill certain requirements and packages are updated at a certain pace. If you want to use other packages or get development versions, you can also install packages from GitHub using the devtools package. Before you can use a certain package in a session, you have to load it using the library() command. library(tidyverse) Now you are good to go! 3.2 Basic arithmetic operations Using R as a calculator looks like this: 5 + 5 ## [1] 10 5 + 5 * 3 ## [1] 20 5 + 5^2 ## [1] 30 sqrt(9) ## [1] 3 The latter, sqrt(), is no classic arithmetic operation but a function. It takes a non-negative number as input and returns its square root. 3.3 Vectors R is vector-based. That implies that we can store multiple values in vectors and perform operations on them by element. This is pretty handy and distinguishes it from other languages like, for instance, C or Python (without NumPy). In R, there are two kinds of vectors: atomic vectors and lists. Atomic vectors can only contain values of one type, whereas lists can contain atomic vectors of different types – and lists as well. It might be hard for you at first to wrap your head around this. However, it will become clear as soon as we fill it with some examples. Vectors can be characterized by two key properties: their type, which can be determined with typeof(), and their length which can be assessed using length(). NULL is the absence of a vector. NA, a missing value, is the absence of a value in a vector. In the following, I first introduce atomic vectors. Afterwards, I describe lists. Finally, augmented vectors are to be introduced: factors, data frames/tibbles, and date/date-times. I will refer to atomic vectors as vectors, and to lists as lists. I will leave out matrices and arrays. We will not work with them in the course, and, honestly, I rarely use them myself. This tutorial borrows heavily from Hadley Wickham’s “R for Data Science” (Wickham and Grolemund 2016), and Richard Cotton’s “Learning R” (Cotton 2013). 3.3.1 Atomic vectors There exist six different types of atomic vectors: logical, integer, double, character, complex, and raw. The latter two are hardly used, hence I will not include them here. Integer and double are usually summarized under the umbrella term numeric vectors. We can create a vector using the c() function. “c” stands for “concatenate.” 3.3.1.1 Logical vectors Logical vectors can take three values: TRUE, FALSE, and NA. While you can create them by hand (logical_vec &lt;- c(TRUE, FALSE, NA)), they are usually the result of comparisons. In R, you have six comparison operators: &lt; &gt; &lt;= &gt;= == (always use two equal signs) != (not equal) 5 &gt; 6 ## [1] FALSE Sometimes, we want to store the results of what we are doing. Then, we assign our operation’s result to a meaningful name: example_logical_vec &lt;- 5 &gt; 6 You may wonder how you should name your objects. In this case, just consult the tidyverse style guide. Here, it says that you should use lowercase letters, numbers, and underscores (called “snake case”). In general, you should stick to the tidyverse style guide. The conventions you can find in there will make your life and the lives of the people who have the honor to read your code a lot easier. And if you find examples in this tutorial where I violate any of the conventions stated there and point it out, I owe you a hot beverage. Logical vectors can also be used in a numerical context. If so, TRUE becomes 1 and FALSE 0. You will see an example when we deal with the conversion of vectors to different types. You can look at vectors by either typing in the name and then executing it, or by calling head(). The latter is especially useful if the vectors are very long, since it only gives back the first 10 values by default. However, you can specify the length of the output by providing a different n argument. example &lt;- c(TRUE, FALSE, FALSE, FALSE, TRUE, TRUE, TRUE, FALSE, FALSE, TRUE, FALSE, TRUE, FALSE, FALSE, FALSE, TRUE, TRUE, TRUE, FALSE, FALSE, TRUE, FALSE, TRUE, FALSE) example # too long ## [1] TRUE FALSE FALSE FALSE TRUE TRUE TRUE FALSE FALSE TRUE FALSE TRUE ## [13] FALSE FALSE FALSE TRUE TRUE TRUE FALSE FALSE TRUE FALSE TRUE FALSE head(example, n = 5) ## [1] TRUE FALSE FALSE FALSE TRUE 3.3.1.2 Numeric vectors Numbers in R are double by default. To make a numeric vector an integer, add L to a number, or use as.integer(). double_vec &lt;- c(1, 2, 3, 4) typeof(double_vec) ## [1] &quot;double&quot; integer_vec &lt;- c(1L, 2L, 3L) typeof(integer_vec) ## [1] &quot;integer&quot; typeof(as.integer(double_vec)) ## [1] &quot;integer&quot; Furthermore, you can create sequences of numbers by using the : operator. This will also give you an integer. new_sequence &lt;- 1:9 new_sequence ## [1] 1 2 3 4 5 6 7 8 9 typeof(new_sequence) ## [1] &quot;integer&quot; Note that doubles are only approximate, since they represent floating point numbers. In your every-day coding, you should not worry too much about it. However, keep it in mind later on. You can read more about it here (page 9). Beyond that, Integers only have one special value – NA, implying a missing value. Doubles have four: NA – missing value, NaN – not a number, and Inf and -Inf – infinite values. The latter three can be illustrated with the following example: c(-1, 0, 1) / 0 ## [1] -Inf NaN Inf And, very important: use decimal points instead of decimal commas (especially applicable to Germans). 3.3.1.3 Character vectors The vectors of type character can consist of more or less anything. The only thing that matters is that their inputs are wrapped with either \" \" or ’ ’ (which can come in handy if you want to store text): another_character &lt;- c(&quot;hi&quot;, &quot;1234&quot;, &quot;!!1!&quot;, &quot;#+*23$%&amp;/(&quot;) typeof(another_character) ## [1] &quot;character&quot; text_character &lt;- &quot;I am my mother&#39;s child.&quot; direct_speech &lt;- &#39;&quot;It has never been easy to learn how to code,&quot; said my professor&#39; You cannot really “do” anything with character vectors, except for comparison. #text_character + direct_speech # remove &#39;#&#39; if you want to try text_character == text_character ## [1] TRUE &quot;b&quot; &gt; &quot;a&quot; ## [1] TRUE 3.3.2 Working with atomic vectors 3.3.2.1 Convert between types You can either explicitly or implicitly convert a vector to a certain type. For explicit conversion, or coercion, you can just call the respective as.xxx() function: as.logical(), as.integer(), as.double(), or as.character(). However, calling these functions often implies that your vector had the wrong type in first place. Hence, try to avoid it if possible, and, therefore, this is used relatively rarely. Implicit conversion happens by using a vector in a context in which a vector of a different type is expected. One example is dealing with logical vectors. As mentioned earlier, TRUE is translated to 1, while FALSE becomes 0. This can come in pretty handy: x &lt;- sample(1000, 100, replace = TRUE) # draw 100 numbers between 1 and 1000 y &lt;- x &gt; 500 # whether numbers are greater than 500 typeof(y) ## [1] &quot;logical&quot; sum(y) # how many are greater than 500 ## [1] 46 mean(y) # proportion of numbers which are greater than 500 ## [1] 0.46 Also, if you build a vector out of multiple types – the most complex type always wins. Here, complex means that a vector can take many different values. Character vectors, for instance, can take basically every value: typeof(c(TRUE, 1L)) ## [1] &quot;integer&quot; typeof(c(1L, 1.5)) ## [1] &quot;double&quot; typeof(c(1.5, &quot;abc&quot;)) ## [1] &quot;character&quot; 3.3.2.2 Naming elements Elements of vectors can be named. This can either happen during creation: named_vector &lt;- c(one = 1, two = 2, three = 3, four = 4, five = 5) Or in hindsight using set_names() from the purrr package (which is part of the core tidyverse and, therefore, does not need to be loaded explicitly): named_vector &lt;- set_names(1:5, c(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;, &quot;five&quot;)) 3.3.2.3 Accessing elements If we want to access a certain element of the vector, we can tell R to do so by using square brackets [ ]. This can also be used for some filtering: named_vector[1] # first element ## one ## 1 named_vector[length(named_vector)] # last element, using a function, again ## five ## 5 named_vector[-3] # all elements but the third ## one two four five ## 1 2 4 5 named_vector[c(1, 3)] # first and third ## one three ## 1 3 named_vector[1:3] # first to third ## one two three ## 1 2 3 named_vector[named_vector == 3] # elements that equal three ## three ## 3 named_vector[named_vector %in% c(1, 2, 3)] # named_vectors that also are in another vector ## one two three ## 1 2 3 named_vector[named_vector &gt; 2] # values that are bigger than 2 ## three four five ## 3 4 5 rev(named_vector) # reverse vector -- using a function ## five four three two one ## 5 4 3 2 1 named_vector[c(1, 1, 1, 2, 3, 3, 3)] # first first first second third third third element ## one one one two three three three ## 1 1 1 2 3 3 3 named_vector[c(TRUE, TRUE, TRUE, FALSE, TRUE)] # subsetting with a logical vector -- TRUE = value at the corresponding position is retained, FALSE = value at the corresponding position is dropped ## one two three five ## 1 2 3 5 named_vector[c(&quot;one&quot;, &quot;three&quot;)] # if the vector is named, you can also select the correspondingly named elements with a character vector ## one three ## 1 3 As stated in the beginning, atomic vectors can only contain data of one type. If we want to store data of several types in one object, we need to use lists. 3.3.3 Lists Lists can contain all types of vectors, including other lists. Due to the latter feature, they are also called “recursive vectors.” Lists can be created using list(). Naming elements works like naming elements of atomic vectors. new_list &lt;- list(numbers = 1:5, characters = c(&quot;Hello&quot;, &quot;world&quot;, &quot;!&quot;), logical_vec = c(TRUE, FALSE), another_list = list(1:5, 6:10)) In theory, you can, for instance, look at a list calling head(): head(new_list) ## $numbers ## [1] 1 2 3 4 5 ## ## $characters ## [1] &quot;Hello&quot; &quot;world&quot; &quot;!&quot; ## ## $logical_vec ## [1] TRUE FALSE ## ## $another_list ## $another_list[[1]] ## [1] 1 2 3 4 5 ## ## $another_list[[2]] ## [1] 6 7 8 9 10 Another possibility, which is especially suitable for lists, is str(), because it focuses on the structure: str(new_list) ## List of 4 ## $ numbers : int [1:5] 1 2 3 4 5 ## $ characters : chr [1:3] &quot;Hello&quot; &quot;world&quot; &quot;!&quot; ## $ logical_vec : logi [1:2] TRUE FALSE ## $ another_list:List of 2 ## ..$ : int [1:5] 1 2 3 4 5 ## ..$ : int [1:5] 6 7 8 9 10 3.3.3.1 Accessing list elements Accessing elements of a list is similar to vectors. There are basically three ways: Using singular square brackets gives you a sub-list: sublist &lt;- new_list[2] sublist ## $characters ## [1] &quot;Hello&quot; &quot;world&quot; &quot;!&quot; typeof(sublist) ## [1] &quot;list&quot; Double square brackets gives you the component: component_1 &lt;- new_list[[1]] component_1 ## [1] 1 2 3 4 5 typeof(component_1) ## [1] &quot;integer&quot; A bit hard to grasp? I certainly agree! You can find a nice real-world metaphor here. If the elements are named, you can also extract them using the $ operator: vector_of_numbers &lt;- new_list$numbers vector_of_numbers ## [1] 1 2 3 4 5 typeof(vector_of_numbers) ## [1] &quot;integer&quot; 3.3.4 Augmented vectors In R, there are also other vector types. They are built upon the basic vectors – atomic vectors and lists. The most important ones are factors (built upon integers), date/date-time (built upon doubles), and data frames/tibbles (built upon lists). 3.3.4.1 Factors Factors are used in R to represent categorical variables. They can only take a limited amount of values. Think for example of something like party affiliation of members of the German parliament. This should be stored as a factor, because you have a limited set of values (i.e., AfD, Buendnis 90/Die Gruenen, CDU, CSU, Die Linke, FDP, SPD, fraktionslos) which apply to multiple politicians. Names, on the other hand, should be stored as characters, since there is (in theory) an infinite number of possible values. Factors are built on top of integers. They have an attribute called “levels.” mdbs &lt;- factor(levels = c(&quot;AfD&quot;, &quot;Buendnis90/Die Gruenen&quot;, &quot;CDU&quot;, &quot;CSU&quot;, &quot;Die Linke&quot;, &quot;SPD&quot;)) levels(mdbs) ## [1] &quot;AfD&quot; &quot;Buendnis90/Die Gruenen&quot; &quot;CDU&quot; ## [4] &quot;CSU&quot; &quot;Die Linke&quot; &quot;SPD&quot; typeof(mdbs) ## [1] &quot;integer&quot; mdbs ## factor(0) ## Levels: AfD Buendnis90/Die Gruenen CDU CSU Die Linke SPD In our daily workflow, we normally convert character vectors to factors using as.factor(). We will learn more about factors – and the forcats package which has been dedicated to them. 3.3.4.2 Date and date-time Dates are simply numeric vectors that indicate the number of days that have passed since 1970-01-01. We will work with dates using the lubridate package. library(lubridate) ## ## Attaching package: &#39;lubridate&#39; ## The following objects are masked from &#39;package:base&#39;: ## ## date, intersect, setdiff, union date &lt;- as.Date(&quot;1970-01-02&quot;) unclass(date) ## [1] 1 typeof(date) ## [1] &quot;double&quot; Date-times work analogously: a numeric vector that represents the number of seconds that have passed since 1970-01-01 00:00:00. datetime &lt;- ymd_hms(&quot;1970-01-01 01:00:00&quot;) unclass(datetime) ## [1] 3600 ## attr(,&quot;tzone&quot;) ## [1] &quot;UTC&quot; If you want to learn more on dates and times, have a look at the lubridate package which has been dedicated to them. 3.3.4.3 Data Frames/Tibbles The data structure in R which is probably the most central for this course – and for working with the tidyverse in general – is the data frame (or Tibble, which is used in the context of the tidy packages). In the following, I will only focus on Tibbles. The differences between a Tibble and a data frame can be found here. It is built upon lists, but there are some crucial differences: Lists can contain everything (including other lists), Tibbles can only contain vectors (including lists) which are of the same length or length 1 (then the value is repeated to make the vector the same length as the others, so-called recycling). These variables need to have a name. For creating tibbles, we need the tibble package which comes with the tidyverse. You can give elements names which are invalid variable names in R (e.g., because they contain spaces) by wrapping them with ``. If you want to work with this variable afterwards, you will also have to wrap its name with back ticks. new_tibble &lt;- tibble( a = 1:5, b = c(&quot;Hi&quot;, &quot;,&quot;, &quot;it&#39;s&quot;, &quot;me&quot;, &quot;!&quot;), `an invalid name` = TRUE ) new_tibble ## # A tibble: 5 × 3 ## a b `an invalid name` ## &lt;int&gt; &lt;chr&gt; &lt;lgl&gt; ## 1 1 Hi TRUE ## 2 2 , TRUE ## 3 3 it&#39;s TRUE ## 4 4 me TRUE ## 5 5 ! TRUE # View(new_tibble) You can access a Tibble’s columns by their name by either using the $ operator, or [[\" – like when you access named elements in a list. This will return the vector: new_tibble$a ## [1] 1 2 3 4 5 typeof(new_tibble$a) ## [1] &quot;integer&quot; new_tibble[[&quot;a&quot;]] ## [1] 1 2 3 4 5 You can also extract by position using [[: new_tibble[[3]] ## [1] TRUE TRUE TRUE TRUE TRUE As it returns a vector, you can extract the vector’s value by just adding the expression in single square brackets: new_tibble[[1]][[2]] # second value of first column ## [1] 2 3.4 Further links More on factors can be found here (McNamara and Horton 2017). “The R Inferno” by Patrick Burns (pun probably not intended) is always nice to come back to (Burns 2011). read the tidyverse style guide – and then stick to it. Probably one of the hardest things in this tutorials to get one’s head around are factors. Here you can find more about them. Some basic tutorials. If you want to learn more about data types, click here. References "],["workingwithdata.html", "Chapter 4 Working with data 4.1 Reading in data sets 4.2 Alternative ways to read in and write data 4.3 Write data 4.4 Tidy data 4.5 Further links", " Chapter 4 Working with data Now we can take a first dive into data wrangling. First of all, we need to read in the data into our R session. I will talk about that maybe longer than I should. Thereafter, we need to make sure that the data is in the right format. You probably have not really thought about how a data set is supposed to look like. The concept of tidy data provides you an idea for this. 4.1 Reading in data sets First, the readr package (Hester et al. 2018) will be introduced. It can be used for the import of the majority of files you will ever want to import and export. If the files become larger, vroom (Hester et al. 2020) is a viable alternative. Beyond that, there exist some more packages for other types such as Excel or Stata files. I will provide you with a basic tutorial on how to deal with them, too. Some notes on the notation: \"file.csv\" relates to the file you want to read in – please note that it needs to be provided as a character vector, tibble to the Tibble you want to write. 4.1.1 The working directory in R As mentioned when introducing RStudio Projects, there are two kinds of file paths you can provide R with: absolute and relative paths. The absolute path for this script on my machine looks like this: “/Users/felixlennert/Documents/phd/teaching/introduction-to-r/03-tidying.Rmd.” If you are on a Windows machine and copy file paths: R uses the file path separator \\ as a so-called escape character – hence, it does not recognize it as a file path separator. You can address this problem by either using double back-slashes \\\\ or using a normal slash, /, instead. There is always a working directory you are in. You can obtain your working directory using getwd(). Relative paths then just build upon it. If you want to change your working directory, use setwd(). Please note that I included the former two paragraphs just for the record. You should never use absolute paths, except for if you are planning to keep the same machine for the rest of your life and never change any of your file structure. You are not. Hence, please use RStudio Projects.4 If you are using RStudio Projects, your working directory defaults to the folder your .Rproj file is stored in. If you are working in RMarkdown, the working directory is where your RMarkdown document is stored in. 4.1.2 readr’s general functions… In general, importing data with readr is pretty hassle-free: the hardest thing about it is calling the right function. It usually takes care of the rest itself, parsing columns properly, etc. However, sometimes you need to specify additional arguments. The following unordered list shows the most common read_*() functions. Usually, you can simply provide them a file path and they load in the data and return a Tibble. If your data is in a compressed file with the extension .gz, .bz2, .xz, or .zip, readr will automatically uncompress it. If the file is stored online, you can provide a URL starting with http://, https://, ftp://, or ftps://. readr will automatically take care of the download process. read_csv(\"file.csv\") reads comma delimited files read_csv2(\"file.csv\") reads semi-colon delimited files and treats commas as decimal separator read_delim(\"file.txt\", delim = \"|\") reads files which are delimited by whatever delimiter you specify (| in this case) read_fwf(\"file.fwf\", col_positions = c(1, 3, 5)) reads fixed width files. Here, some sort of data on the columns must be provided, e.g., their positions in the file If the values are separated by white space, you can also use read_tsv(\"file.tsv\") or read_table(\"file.tsv\") 4.1.3 …and their additional arguments Also, all these functions share certain arguments which just need to be included in the call. In the following, I will enumerate the most useful ones. If your file does not have a header (most of the time, column names), provide col_names = FALSE. The resulting Tibble will have X1 … Xn as column names If your file does not have column names, but you want the resulting Tibble to have some, you can specify them with col_names = c(\"a\", \"b\", \"c\"). It takes a character vector. If there are rows you do not want to be considered, you can use skip =. For instance, read_csv(\"file.csv\", skip = 6) reads everything but the first six data rows (the very first row is not taken into consideration as well) Sometimes the original creator of your data set might go across missing values differently than you would want it to. na = can be used to specify which values shall be considered missing. If your missings are coded as 99 and 999, for instance, you can address that in the read-in process already by using read_csv(\"file.csv\", na = c(\"99\", \"999\")). Please note that it takes a character vector as argument In some data sets, the first rows consists of comments that start with particular signs or special characters. Using comment = allows you to skip these lines. For instance, read_csv(\"file.csv\", comment = \"#\") drops all the rows that begin with a hash. 4.1.4 Column types As you have already learned in the script before, a Tibble consists of multiple vectors of the same length. The vectors can be of different types. When you read in data using readr, it will print out the column types it has guessed. When you read in data, you must ascribe it to an object in your environment. The following code reads in a .csv file with data on the 100 most-played songs on Spotify in 2018 and stores it in the object spotify_top100_2018. library(tidyverse) # library(readr) --&gt; no need to load readr, it&#39;s part of the core tidyverse spotify_top100_2018 &lt;- read_csv(&quot;data/spotify2018.csv&quot;) ## Rows: 100 Columns: 16 ## ── Column specification ──────────────────────────────────────────────────────── ## Delimiter: &quot;,&quot; ## chr (3): id, name, artists ## dbl (13): danceability, energy, key, loudness, mode, speechiness, acousticne... ## ## ℹ Use `spec()` to retrieve the full column specification for this data. ## ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message. If your data is well-behaved, R will guess the vector types correctly and everything will run smoothly. However, sooner or later you will stumble across a data set which is not well-behaved. This is where knowing how to fine-tune your parsing process up-front will eventually save you a lot of head scratching. But how does parsing actually look like. Well, readr’s parsing functions take a character vector and return a more specialized vector. parse_double(c(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;)) ## [1] 1 2 3 So far so good. What readr does when it reads in your data sets is that it tries to guess the correct data type. This can be emulated using guess_parser() and parse_guess(). Both functions take a character vector as input. The former one returns the guessed type, the latter returns a vector which is parsed to the type it has guessed. guess_parser(&quot;2009-04-23&quot;) ## [1] &quot;date&quot; str(parse_guess(&quot;2009-04-23&quot;)) ## Date[1:1], format: &quot;2009-04-23&quot; The heuristic it uses is fairly simple yet robust. However, there are common cases when you might run into problems with different data types. In the following, I will show you the two most common ones. The first one regards numeric data, the second one data on date and time. 4.1.4.1 Numbers Parsing numbers should be straight-forward, right, so what could possibly go wrong? Well… Decimal points Special characters ($, %, §, €) So-called grouping characters such as 1,000,000 (USA) or 1.000.000 (Germany) or 1’000’000 (Switzerland) The problem with decimal points (– and commas) can be addressed by specifying a locale. Compare: parse_double(&quot;1,3&quot;) ## Warning: 1 parsing failure. ## row col expected actual ## 1 -- no trailing characters 1,3 ## [1] NA ## attr(,&quot;problems&quot;) ## # A tibble: 1 × 4 ## row col expected actual ## &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; ## 1 1 NA no trailing characters 1,3 parse_double(&quot;1,3&quot;, locale = locale(decimal_mark = &quot;,&quot;)) ## [1] 1.3 The special character problem can be addressed using parse_number instead of parse_double: it will ignore the special characters. parse_number(&quot;1.5€&quot;) ## [1] 1.5 The last problem can be addressed using another locale. parse_number(&quot;1.300.000&quot;, locale = locale(grouping_mark = &quot;.&quot;)) ## [1] 1300000 4.1.4.2 Date and time Date vectors in R are numeric vectors indicating how many days have passed since 1970. Date-Time vectors indicate the seconds since 1970-01-01 00:00:00. Time vectors indicate the number of seconds since midnight. The parse_*() functions expect the vectors to be in a certain format: parse_datetime() expects the input to follow the ISO8601 standard. The times components must be ordered from biggest to smallest: year, month, day, hour, minute, second. parse_datetime(&quot;2000-02-29T2000&quot;) ## [1] &quot;2000-02-29 20:00:00 UTC&quot; parse_date() wants a four digit year, two digit month, and two digit day. They can be separated by either “-” or “/.” parse_date(&quot;2000-02-29&quot;) ## [1] &quot;2000-02-29&quot; parse_date(&quot;2000/02/29&quot;) ## [1] &quot;2000-02-29&quot; Do you wonder why I chose 2000-02-29? It’s R’s birthday… parse_time() needs at least hours and minutes, seconds are optional. They need to be separated by colons. There is no proper built-in class for time data in Base R. Hence, I will use the hms package here. library(hms) ## ## Attaching package: &#39;hms&#39; ## The following object is masked from &#39;package:lubridate&#39;: ## ## hms parse_time(&quot;20:15:00&quot;) ## 20:15:00 parse_time(&quot;20:15&quot;) # both works ## 20:15:00 When it comes to dates, you can also build your own format. Just mash together the following pieces: Year: %Y – year in 4 digits; %y – year in two digits following this rule: 00–69 = 2000–2069, 70–99 = 1970–1999 Month: %m – two digits; %b – abbreviated name (e.g., “Nov”); %B – full name (e.g., “November”) Day: %d – two digits Time: %H – hour, 0–23; %h – hour, 1–12, must come together with %p – a.m./p.m. indicator; %M – minutes; %S – integer seconds; %Z time zone – America/Chicago for instance Non-digits: %. skips one non-digit character; %* skips any number of non-digits You might see that there can emerge problems with this. You might, for example, have something like this: example_date &lt;- &quot;29. Februar 2000&quot; So how can you parse this date with a German month name? Again, you can use locale =. date_names_langs() # what could be the proper abbreviation? ## [1] &quot;af&quot; &quot;agq&quot; &quot;ak&quot; &quot;am&quot; &quot;ar&quot; &quot;as&quot; &quot;asa&quot; &quot;az&quot; &quot;bas&quot; &quot;be&quot; &quot;bem&quot; &quot;bez&quot; ## [13] &quot;bg&quot; &quot;bm&quot; &quot;bn&quot; &quot;bo&quot; &quot;br&quot; &quot;brx&quot; &quot;bs&quot; &quot;ca&quot; &quot;cgg&quot; &quot;chr&quot; &quot;cs&quot; &quot;cy&quot; ## [25] &quot;da&quot; &quot;dav&quot; &quot;de&quot; &quot;dje&quot; &quot;dsb&quot; &quot;dua&quot; &quot;dyo&quot; &quot;dz&quot; &quot;ebu&quot; &quot;ee&quot; &quot;el&quot; &quot;en&quot; ## [37] &quot;eo&quot; &quot;es&quot; &quot;et&quot; &quot;eu&quot; &quot;ewo&quot; &quot;fa&quot; &quot;ff&quot; &quot;fi&quot; &quot;fil&quot; &quot;fo&quot; &quot;fr&quot; &quot;fur&quot; ## [49] &quot;fy&quot; &quot;ga&quot; &quot;gd&quot; &quot;gl&quot; &quot;gsw&quot; &quot;gu&quot; &quot;guz&quot; &quot;gv&quot; &quot;ha&quot; &quot;haw&quot; &quot;he&quot; &quot;hi&quot; ## [61] &quot;hr&quot; &quot;hsb&quot; &quot;hu&quot; &quot;hy&quot; &quot;id&quot; &quot;ig&quot; &quot;ii&quot; &quot;is&quot; &quot;it&quot; &quot;ja&quot; &quot;jgo&quot; &quot;jmc&quot; ## [73] &quot;ka&quot; &quot;kab&quot; &quot;kam&quot; &quot;kde&quot; &quot;kea&quot; &quot;khq&quot; &quot;ki&quot; &quot;kk&quot; &quot;kkj&quot; &quot;kl&quot; &quot;kln&quot; &quot;km&quot; ## [85] &quot;kn&quot; &quot;ko&quot; &quot;kok&quot; &quot;ks&quot; &quot;ksb&quot; &quot;ksf&quot; &quot;ksh&quot; &quot;kw&quot; &quot;ky&quot; &quot;lag&quot; &quot;lb&quot; &quot;lg&quot; ## [97] &quot;lkt&quot; &quot;ln&quot; &quot;lo&quot; &quot;lt&quot; &quot;lu&quot; &quot;luo&quot; &quot;luy&quot; &quot;lv&quot; &quot;mas&quot; &quot;mer&quot; &quot;mfe&quot; &quot;mg&quot; ## [109] &quot;mgh&quot; &quot;mgo&quot; &quot;mk&quot; &quot;ml&quot; &quot;mn&quot; &quot;mr&quot; &quot;ms&quot; &quot;mt&quot; &quot;mua&quot; &quot;my&quot; &quot;naq&quot; &quot;nb&quot; ## [121] &quot;nd&quot; &quot;ne&quot; &quot;nl&quot; &quot;nmg&quot; &quot;nn&quot; &quot;nnh&quot; &quot;nus&quot; &quot;nyn&quot; &quot;om&quot; &quot;or&quot; &quot;os&quot; &quot;pa&quot; ## [133] &quot;pl&quot; &quot;ps&quot; &quot;pt&quot; &quot;qu&quot; &quot;rm&quot; &quot;rn&quot; &quot;ro&quot; &quot;rof&quot; &quot;ru&quot; &quot;rw&quot; &quot;rwk&quot; &quot;sah&quot; ## [145] &quot;saq&quot; &quot;sbp&quot; &quot;se&quot; &quot;seh&quot; &quot;ses&quot; &quot;sg&quot; &quot;shi&quot; &quot;si&quot; &quot;sk&quot; &quot;sl&quot; &quot;smn&quot; &quot;sn&quot; ## [157] &quot;so&quot; &quot;sq&quot; &quot;sr&quot; &quot;sv&quot; &quot;sw&quot; &quot;ta&quot; &quot;te&quot; &quot;teo&quot; &quot;th&quot; &quot;ti&quot; &quot;to&quot; &quot;tr&quot; ## [169] &quot;twq&quot; &quot;tzm&quot; &quot;ug&quot; &quot;uk&quot; &quot;ur&quot; &quot;uz&quot; &quot;vai&quot; &quot;vi&quot; &quot;vun&quot; &quot;wae&quot; &quot;xog&quot; &quot;yav&quot; ## [181] &quot;yi&quot; &quot;yo&quot; &quot;zgh&quot; &quot;zh&quot; &quot;zu&quot; parse_date(example_date, format = &quot;%d%. %B %Y&quot;, locale = locale(date_names = &quot;de&quot;)) ## [1] &quot;2000-02-29&quot; Now you know how to parse number and date vectors yourself. This is nice, but normally you do not want to read in data, put it into character vectors and then parse it to the right data format. You want to read in a data set and get a Tibble whose columns consist of data which have been parsed to the right type already. 4.1.4.3 Parsing entire files As mentioned earlier, the read_* functions guess the columns format. I emulated this using the guess_parser() function. If you want to specify the column types yourself, you can use the col_types = argument: challenge_w_date &lt;- read_csv(readr_example(&quot;challenge.csv&quot;), col_types = cols( x = col_number(), y = col_date() )) In general, every parse_* function has its col_* counterpart. 4.2 Alternative ways to read in and write data There do also other packages exist for different data types. I will explain the ones which might be of particular use for you and their main-functions only briefly. 4.2.1 haven You can use haven (Wickham and Miller 2020) for reading and writing SAS (suffixes .sas7bdat, .sas7bcat, and .xpt), SPSS (suffixes .sav and .por), and STATA (suffix .dta) files. The functions then are: read_sas(\"file.sas7bdate\") and write_sas(tibble, \"file.sas7bdat\") for both .sas7bdat and .sas7bcat files. read_xpt(\"file.xpt\") reads .xpt files read_sav(\"file.sav\") and read_por(\"file.por\") for .sav and .por files. write_sav(tibble, \"file.sav\" writes a the Tibble tibble to the file file.sav read_dta(\"file.dta\") and write_dta(tibble, \"file.dta\") read and write .dta files The additional arguments can be found in the vignette. 4.2.2 readxl readxl (Wickham, Bryan, et al. 2019) can be used to read Excel files. read_excel(\"file.xls\") works for both .xls and .xlsx files alike. It guesses the data type from the suffix. Excel files often consist of multiple sheets. excel_sheets(\"file.xlsx\") returns the name of the singular sheets. When dealing with an Excel file that contains multiple sheets, you need to specify the sheet you are after in the read_excel() function: read_excel(\"file.xlsx\", sheet = \"sheet_1\"). Please note that it only takes one sheet at a time. More on the readxl package can be found here. 4.2.3 vroom vroom has been introduced recently. It claims to be able to read in delimited files with up to 1.4 GB/s. Regarding its arguments, vroom works in the same way as the read_*() functions from the readr package. I would recommend you to use vroom as soon as your data set’s size exceeds ~100 MB. More on vroom here and here. 4.2.4 .rds and .RDatafiles .rds files can be used to store singular R-specific objects (such as lists), .RData files can be used to store multiple R-specific objects. The former can be read in using read_rds(\"file.rds\"), the latter with load(\"file.RData\"). More on read_rds() here and .RData here 4.3 Write data 4.3.1 write_csv() Writing data is fairly straight-forward. Most of the times, you will work with plain Tibbles which consist of different kinds of vectors except for lists. If you want to store them, I recommend you to simply use write_csv(tibble, path = \"file.csv\"). If you plan on working on the .csv file in Excel, use write_excel_csv(tibble, path = \"file.csv\") 4.3.2 write_rds() Sometimes, however, it might be impossible to create a .csv file of your data – e.g., if you want to store a list. This is what you can use write_rds(r_specific_object, path = \"file.rds\") for. 4.3.3 save() Akin to .rds files are .RData files. They can contain multiple objects and be written using save(r_specific_object_1, r_specific_object_2, r_specific_object_n, file = \"file.RData\"). You can save your entire work space as well by calling save.image(file = \"file.RData\"). 4.3.4 Further readings Information on working directories Websites of the singular packages: readr, haven, readxl, vroom readr Cheatsheet Chapter in R for Data Science (Wickham and Grolemund 2016) regarding data import 4.4 Tidy data Before you learn how to tidy and wrangle data, you need to know how you want your data set to actually look like, i.e., what the desired outcome of the entire process of tidying your data set is. The tidyverse is a collection of packages which share an underlying philosophy: they are tidy. This means, that they (preferably) take tidy data as inputs and output tidy data. In the following, I will, first, introduce you to the concept of tidy data as developed by Hadley Wickham (Wickham 2014). Second, tidyr is introduced (Wickham 2020b). Its goal is to provide you with functions that facilitate tidying data sets. Beyond, I will provide you some examples of how to create tibbles using functions from the tibble package (Müller, Wickham, and François 2020). Moreover, the pipe from the magrittr package is introduced. Please note that tidying and cleaning data are not equivalent: I refer to tidying data as to bringing data in a tidy format. Cleaning data, however, can encompass way more than this: parsing columns in the right format (using readr, for instance), imputation of missing values, address the problem of typos, etc. 4.4.1 In theory Data sets can be structured in many ways. To make them tidy, they must be organized in the following way (this is taken from the R for Data Science book (Wickham and Grolemund 2016)): Each variable must have its own column. Each observation must have its own row. Each value must have its own cell. They can even be boiled further down: Put each data set in a tibble. Put each variable in a column. This can also be visually depicted: The three rules that make a dataset tidy (taken from Wickham and Grolemund 2016: 149) This way of storing data has two big advantages: you can easily access, and hence manipulate, variables as vectors if you perform vectorized operations on the tibble, cases are preserved. 4.4.2 In practice So what are the most common problems with data sets? The following list is taken from the tidyr vignette5: Column headers are values, not variable names. Variables are stored in both rows and columns. Multiple variables are stored in one column. Multiple types of observational units are stored in the same table. A single observational unit is stored in multiple tables. I will go across the former three types of problems, because the latter two require some more advanced data wrangling techniques you haven’t learned yet (i.e., functions from the dplyr package: select(), mutate(), left_join(), among others). In the following, I will provide you with examples on how this might look like and how you can address the respective problem using functions from the tidyr package. This will serve as an introduction to the two most important functions of the tidyr package: pivot_longer() and its counterpart pivot_wider(). Beyond that, separate() will be introduced as well. At the beginning of every part, I will build the tibble using functions from the tibble package. This should suffice as a quick refresher for and introduction to creating tibbles. tidyr has some more functions in stock. They do not necessarily relate to transforming messy data sets into tidy ones, but also serve you well for some general cleaning tasks. They will be introduced, too. 4.4.2.1 Column headers are values A data set of this form would look like this: tibble_value_headers &lt;- tibble( manufacturer = c(&quot;Audi&quot;, &quot;BMW&quot;, &quot;Mercedes&quot;, &quot;Opel&quot;, &quot;VW&quot;), `3 cyl` = sample(20, 5, replace = TRUE), `4 cyl` = sample(50:100, 5, replace = TRUE), `5 cyl` = sample(10, 5, replace = TRUE), `6 cyl` = sample(30:50, 5, replace = TRUE), `8 cyl` = sample(20:40, 5, replace = TRUE), `10 cyl` = sample(10, 5, replace = TRUE), `12 cyl` = sample(20, 5, replace = TRUE), `16 cyl` = rep(0, 5) ) tibble_value_headers ## # A tibble: 5 × 9 ## manufacturer `3 cyl` `4 cyl` `5 cyl` `6 cyl` `8 cyl` `10 cyl` `12 cyl` ## &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 Audi 5 97 7 48 25 10 13 ## 2 BMW 18 84 8 32 40 2 3 ## 3 Mercedes 3 70 7 43 28 3 17 ## 4 Opel 5 86 3 44 39 10 13 ## 5 VW 6 95 5 48 26 5 18 ## # … with 1 more variable: 16 cyl &lt;dbl&gt; You can create a tibble by column using the tibble function. Column names need to be specified and linked to vectors of either the same length or length one. This data set basically consists of three variables: German car manufacturer, number of cylinders, and frequency. To make the data set tidy, it has to consist of three columns depicting the three respective variables. This operation is called pivoting the non-variable columns into two-column key-value pairs. As the data set will thereafter contain fewer columns and more rows than before, it will have become longer (or taller). Hence, the tidyr function is called pivot_longer(). ger_car_manufacturer_longer &lt;- tibble_value_headers %&gt;% pivot_longer(-manufacturer, names_to = &quot;cylinders&quot;, values_to = &quot;frequency&quot;) ger_car_manufacturer_longer ## # A tibble: 40 × 3 ## manufacturer cylinders frequency ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Audi 3 cyl 5 ## 2 Audi 4 cyl 97 ## 3 Audi 5 cyl 7 ## 4 Audi 6 cyl 48 ## 5 Audi 8 cyl 25 ## 6 Audi 10 cyl 10 ## 7 Audi 12 cyl 13 ## 8 Audi 16 cyl 0 ## 9 BMW 3 cyl 18 ## 10 BMW 4 cyl 84 ## # … with 30 more rows In the function call, you need to specify the following: if you were not to use the pipe, the first argument would be the tibble you are manipulating. Then, you look at the column you want to keep. Here, it is the car manufacturer. This means that all columns but manufacturer will be crammed into two new ones: one will contain the columns’ names, the other one their values. How are those new column supposed to be named? That can be specified in the names_to = and values_to =arguments. Please note that you need to provide them a character vector, hence, surround your parameters with quotation marks. As a rule of thumb for all tidyverse packages: If it is a new column name you provide, surround it with quotation marks. If it is one that already exists – like, here, manufacturer, then you do not need the quotation marks. 4.4.2.2 Variables in both rows and columns You have this data set: car_models_fuel &lt;- tribble(~manufacturer, ~model, ~cylinders, ~fuel_consumption_type, ~fuel_consumption_per_100km, &quot;VW&quot;, &quot;Golf&quot;, 4, &quot;urban&quot;, 5.2, &quot;VW&quot;, &quot;Golf&quot;, 4, &quot;extra urban&quot;, 4.5, &quot;Opel&quot;, &quot;Adam&quot;, 4, &quot;urban&quot;, 4.9, &quot;Opel&quot;, &quot;Adam&quot;, 4, &quot;extra urban&quot;, 4.1) car_models_fuel ## # A tibble: 4 × 5 ## manufacturer model cylinders fuel_consumption_type fuel_consumption_per_100km ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 VW Golf 4 urban 5.2 ## 2 VW Golf 4 extra urban 4.5 ## 3 Opel Adam 4 urban 4.9 ## 4 Opel Adam 4 extra urban 4.1 It was created using the tribble function: tibbles can also be created by row. First, the column names need to be specified by putting a tilde (~) in front of them. Then, you can put in values separated by commas. Please note that the number of values needs to be a multiple of the number of columns. In this data set, there are basically five variables: manufacturer, model, cylinders, urban fuel consumption, and extra urban fuel consumption. However, the column fuel_consumption_type does not store a variable but the names of two variables. Hence, you need to fix this to make the data set tidy. Because this encompasses reducing the number of rows, the data set becomes wider. The function to achieve this is therefore called pivot_wider() and the inverse of pivot_longer(). car_models_fuel_tidy &lt;- car_models_fuel %&gt;% pivot_wider(names_from = fuel_consumption_type, values_from = fuel_consumption_per_100km) car_models_fuel_tidy ## # A tibble: 2 × 5 ## manufacturer model cylinders urban `extra urban` ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 VW Golf 4 5.2 4.5 ## 2 Opel Adam 4 4.9 4.1 Here, you only need to specify the columns you fetch the names and values from. As they both do already exist, you do not need to wrap them in quotation marks. 4.4.2.3 Multiple variables in one column Now, however, there is a problem with the cylinders: their number should be depicted in a numeric vector. We could achieve this by either parsing it to a numeric vector: parse_number(ger_car_manufacturer_longer$cylinders) ## [1] 3 4 5 6 8 10 12 16 3 4 5 6 8 10 12 16 3 4 5 6 8 10 12 16 3 ## [26] 4 5 6 8 10 12 16 3 4 5 6 8 10 12 16 On the other hand, we can also use a handy function from tidyr called separate() and afterwards drop the unnecessary column: ger_car_manufacturer_longer_sep_cyl &lt;- ger_car_manufacturer_longer %&gt;% # first, take the tibble separate(cylinders, into = c(&quot;cylinders&quot;, &quot;drop_it&quot;), sep = &quot; &quot;) %&gt;% # and then split the column &quot;cylinders&quot; into two select(-drop_it) # you will learn about this in the lesson on dplyr # and then drop one column from the tibble If there are two (or actually more) relevant values in one column, you can simply let out the dropping process and easily split them into multiple columns. By default, the sep = argument divides the content by all non-alphanumeric characters (every character that is not a letter, number, or space) it contains. Please note that the new column is still in character format. We can change this using as.numeric(): ger_car_manufacturer_longer_sep_cyl$cylinders &lt;- as.numeric(ger_car_manufacturer_longer_sep_cyl$cylinders) Furthermore, you might want to sort your data in a different manner. If you want to do this by cylinders, it would look like this: arrange(ger_car_manufacturer_longer_sep_cyl, cylinders) ## # A tibble: 40 × 3 ## manufacturer cylinders frequency ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Audi 3 5 ## 2 BMW 3 18 ## 3 Mercedes 3 3 ## 4 Opel 3 5 ## 5 VW 3 6 ## 6 Audi 4 97 ## 7 BMW 4 84 ## 8 Mercedes 4 70 ## 9 Opel 4 86 ## 10 VW 4 95 ## # … with 30 more rows 4.4.2.4 Insertion: the pipe Have you noticed the %&gt;%? That’s the pipe. It’s from the magrittr package (Bache and Wickham 2014) whose name is based on the Belgian painter who has created this masterpiece: Just kidding: It can be considered a conjunction in coding. Usually, you will use it when working with tibbles. What it does is pretty straight-forward: it takes what is on its left – the input – and provides it to the function on its right as the first argument. Hence, the code in the last chunk, which looks like this arrange(ger_car_manufacturer_longer_sep_cyl, cylinders) ## # A tibble: 40 × 3 ## manufacturer cylinders frequency ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Audi 3 5 ## 2 BMW 3 18 ## 3 Mercedes 3 3 ## 4 Opel 3 5 ## 5 VW 3 6 ## 6 Audi 4 97 ## 7 BMW 4 84 ## 8 Mercedes 4 70 ## 9 Opel 4 86 ## 10 VW 4 95 ## # … with 30 more rows could have also been written like this ger_car_manufacturer_longer_sep_cyl %&gt;% arrange(cylinders) ## # A tibble: 40 × 3 ## manufacturer cylinders frequency ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Audi 3 5 ## 2 BMW 3 18 ## 3 Mercedes 3 3 ## 4 Opel 3 5 ## 5 VW 3 6 ## 6 Audi 4 97 ## 7 BMW 4 84 ## 8 Mercedes 4 70 ## 9 Opel 4 86 ## 10 VW 4 95 ## # … with 30 more rows because the tibble is the first argument in the function call. Because magrittr really has gained traction in the R community, many functions are now optimized for being used with the pipe. However, there are still some around which are not. A function for fitting a basic linear model with one dependent and one independent variable which are both stored in a tibble looks like this: lm(formula = dv ~ iv, data = tibble). Here, the tibble is not the first argument. To be able to fit a linear model in a “pipeline,” you need to employ a little hack: you can use a dot . as a placeholder. Let’s check out the effect the number of cylinders has on the number of models: ger_car_manufacturer_longer_sep_cyl %&gt;% lm(frequency ~ cylinders, data = .) %&gt;% summary() ## ## Call: ## lm(formula = frequency ~ cylinders, data = .) ## ## Residuals: ## Min 1Q Median 3Q Max ## -36.491 -17.383 0.395 12.964 60.578 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 48.6949 8.6950 5.600 2.01e-06 *** ## cylinders -3.0681 0.9646 -3.181 0.00292 ** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 25.34 on 38 degrees of freedom ## Multiple R-squared: 0.2102, Adjusted R-squared: 0.1895 ## F-statistic: 10.12 on 1 and 38 DF, p-value: 0.002924 As %&gt;% is a bit tedious to type, there exist shortcuts: shift-ctrl-m on a Mac, shift-ctrl-m on a Windows machine. 4.4.2.5 Further functionalities 4.4.2.5.1 Splitting and merging cells If there are multiple values in one column/cell and you want to split them and put them into two rows instead of columns, tidyr offers you the separate_rows() function. german_cars_vec &lt;- c(Audi = &quot;A1, A3, A4, A5, A6, A7, A8&quot;, BMW = &quot;1 Series, 2 Series, 3 Series, 4 Series, 5 Series, 6 Series, 7 Series, 8 Series&quot;) german_cars_tbl &lt;- enframe(german_cars_vec, name = &quot;brand&quot;, value = &quot;model&quot;) german_cars_tbl ## # A tibble: 2 × 2 ## brand model ## &lt;chr&gt; &lt;chr&gt; ## 1 Audi A1, A3, A4, A5, A6, A7, A8 ## 2 BMW 1 Series, 2 Series, 3 Series, 4 Series, 5 Series, 6 Series, 7 Series, 8… tidy_german_cars_tbl &lt;- german_cars_tbl %&gt;% separate_rows(model, sep = &quot;, &quot;) enframe() enables you to create a tibble from a (named) vector. It outputs a tibble with two columns (name and value by default): name contains the names of the elements (if the elements are unnamed, it contains a serial number), value the element. Both can be renamed in the function call by providing a character vector. If you want to achieve the opposite, i.e., merge cells’ content, you can use the counterpart, unite(). Let’s take the following data frame which consists of the names of the professors of the Institute for Political Science at the University of Regensburg: professor_names_df &lt;- data.frame(first_name = c(&quot;Karlfriedrich&quot;, &quot;Martin&quot;, &quot;Jerzy&quot;, &quot;Stephan&quot;, &quot;Melanie&quot;), last_name = c(&quot;Herb&quot;, &quot;Sebaldt&quot;, &quot;Maćków&quot;, &quot;Bierling&quot;, &quot;Walter-Rogg&quot;)) professor_names_tbl &lt;- professor_names_df %&gt;% as_tibble() %&gt;% unite(first_name, last_name, col = &quot;name&quot;, sep = &quot; &quot;, remove = TRUE, na.rm = FALSE) professor_names_tbl ## # A tibble: 5 × 1 ## name ## &lt;chr&gt; ## 1 Karlfriedrich Herb ## 2 Martin Sebaldt ## 3 Jerzy Maćków ## 4 Stephan Bierling ## 5 Melanie Walter-Rogg unite() takes the tibble it should be applied to as the first argument (not necessary if you use the pipe). Then, it takes the two or more columns as arguments (actually, this is not necessary if you want to unite all columns). col = takes a character vector to specify the name of the resulting, new column. remove = TRUE indicates that the columns that are united are removed as well. You can, of course, set it to false, too. na.rm = FALSE finally indicates that missing values are not to be removed prior to the uniting process. Here, the final variant of creating tibbles is introduced as well: you can apply the function as_tibble() to a data frame and it will then be transformed into a tibble. 4.5 Further links Hadley on tidy data The two pivot_*() functions lie at the heart of tidyr. This article from the Northeastern University’s School of Journalism explains it in further detail. References "],["wrangling.html", "Chapter 5 Manipulation with dplyr 5.1 Working with the main “verbs” 5.2 Introducing joins 5.3 Further links", " Chapter 5 Manipulation with dplyr The last chapter showed you four things: how you get data sets into R, a couple of ways to create tibbles, how to pass data to functions using the pipe (%&gt;%), and an introduction to tidy data and how to make data sets tidy using the tidyr package (Wickham 2020b). What you haven’t learned was how you can actually manipulate the data itself. In the tidyverse framework (Wickham, Averick, et al. 2019), the package which enables you to accomplish those tasks is dplyr (Wickham 2020a). dplyr joined the party in 2014, building upon the plyr package. The d in dplyr stands for data set and dplyr works with tibbles (or data frames) only. It consists of five main functions, the “verbs”: arrange() – sort values filter() – pick observations mutate() – create new variables (columns) select() – select variables summarize() – create summaries from multiple values They are joined by group_by(), a function that changes the scope on which entities the functions are applied to. Furthermore, diverse bind_ functions and _joins enable you to combine multiple tibbles into one. They will be introduced later. 5.1 Working with the main “verbs” In the following, I will guide you through how you can use the verbs to accomplish whatever goals which require data wrangling you might have. The data set I will use here consists of the 1,000 most popular movies on IMDb which were published between 2006 and 2016 and some data on them. It was created by PromptCloud and DataStock and published on Kaggle, more information can be found here. library(tidyverse) imdb_raw &lt;- read_csv(&quot;data/imdb2006-2016.csv&quot;) The data set hasn’t been modified by me before. I will show you how I would go across it using a couple of dplyr functions. 5.1.1 select() select enables you to select columns. Since we are dealing with tidy data, every variable has its own column. glimpse() provides you with an overview of the data set and its columns. glimpse(imdb_raw) ## Rows: 1,000 ## Columns: 12 ## $ Rank &lt;dbl&gt; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15… ## $ Title &lt;chr&gt; &quot;Guardians of the Galaxy&quot;, &quot;Prometheus&quot;, &quot;Split&quot;,… ## $ Genre &lt;chr&gt; &quot;Action,Adventure,Sci-Fi&quot;, &quot;Adventure,Mystery,Sci… ## $ Description &lt;chr&gt; &quot;A group of intergalactic criminals are forced to… ## $ Director &lt;chr&gt; &quot;James Gunn&quot;, &quot;Ridley Scott&quot;, &quot;M. Night Shyamalan… ## $ Actors &lt;chr&gt; &quot;Chris Pratt, Vin Diesel, Bradley Cooper, Zoe Sal… ## $ Year &lt;dbl&gt; 2014, 2012, 2016, 2016, 2016, 2016, 2016, 2016, 2… ## $ `Runtime (Minutes)` &lt;dbl&gt; 121, 124, 117, 108, 123, 103, 128, 89, 141, 116, … ## $ Rating &lt;dbl&gt; 8.1, 7.0, 7.3, 7.2, 6.2, 6.1, 8.3, 6.4, 7.1, 7.0,… ## $ Votes &lt;dbl&gt; 757074, 485820, 157606, 60545, 393727, 56036, 258… ## $ `Revenue (Millions)` &lt;dbl&gt; 333.13, 126.46, 138.12, 270.32, 325.02, 45.13, 15… ## $ Metascore &lt;dbl&gt; 76, 65, 62, 59, 40, 42, 93, 71, 78, 41, 66, 74, 6… The columns I want to keep are: Title, Director, Year, Runtime (Minutes), Rating, Votes, and Revenue (Millions). Furthermore, I want to rename the columns: every column’s name should be in lowercase and a regular name that does not need to be surrounded by back ticks – i.e., a name that only consists of characters, numbers, underscores, or dots. This can be achieved in a couple of ways: First, by choosing the columns column by column and subsequently renaming them: imdb_raw %&gt;% select(Title, Director, Year, `Runtime (Minutes)`, Rating, Votes, `Revenue (Millions)`) %&gt;% rename(title = Title, director = Director, year = Year, runtime = `Runtime (Minutes)`, rating = Rating, votes = Votes, revenue_million = `Revenue (Millions)`) %&gt;% glimpse() ## Rows: 1,000 ## Columns: 7 ## $ title &lt;chr&gt; &quot;Guardians of the Galaxy&quot;, &quot;Prometheus&quot;, &quot;Split&quot;, &quot;Sin… ## $ director &lt;chr&gt; &quot;James Gunn&quot;, &quot;Ridley Scott&quot;, &quot;M. Night Shyamalan&quot;, &quot;C… ## $ year &lt;dbl&gt; 2014, 2012, 2016, 2016, 2016, 2016, 2016, 2016, 2016, … ## $ runtime &lt;dbl&gt; 121, 124, 117, 108, 123, 103, 128, 89, 141, 116, 133, … ## $ rating &lt;dbl&gt; 8.1, 7.0, 7.3, 7.2, 6.2, 6.1, 8.3, 6.4, 7.1, 7.0, 7.5,… ## $ votes &lt;dbl&gt; 757074, 485820, 157606, 60545, 393727, 56036, 258682, … ## $ revenue_million &lt;dbl&gt; 333.13, 126.46, 138.12, 270.32, 325.02, 45.13, 151.06,… Second, the columns can also be chosen vice versa: unnecessary columns can be dropped using a minus: imdb_raw %&gt;% select(-Rank, -Genre, -Description, -Actors, -Metascore) %&gt;% rename(title = Title, director = Director, year = Year, runtime = `Runtime (Minutes)`, rating = Rating, votes = Votes, revenue_million = `Revenue (Millions)`) %&gt;% glimpse() ## Rows: 1,000 ## Columns: 7 ## $ title &lt;chr&gt; &quot;Guardians of the Galaxy&quot;, &quot;Prometheus&quot;, &quot;Split&quot;, &quot;Sin… ## $ director &lt;chr&gt; &quot;James Gunn&quot;, &quot;Ridley Scott&quot;, &quot;M. Night Shyamalan&quot;, &quot;C… ## $ year &lt;dbl&gt; 2014, 2012, 2016, 2016, 2016, 2016, 2016, 2016, 2016, … ## $ runtime &lt;dbl&gt; 121, 124, 117, 108, 123, 103, 128, 89, 141, 116, 133, … ## $ rating &lt;dbl&gt; 8.1, 7.0, 7.3, 7.2, 6.2, 6.1, 8.3, 6.4, 7.1, 7.0, 7.5,… ## $ votes &lt;dbl&gt; 757074, 485820, 157606, 60545, 393727, 56036, 258682, … ## $ revenue_million &lt;dbl&gt; 333.13, 126.46, 138.12, 270.32, 325.02, 45.13, 151.06,… Columns can also be renamed in the selecting process: imdb_raw %&gt;% select(title = Title, director = Director, year = Year, runtime = `Runtime (Minutes)`, rating = Rating, votes = Votes, revenue_million = `Revenue (Millions)`) %&gt;% glimpse() ## Rows: 1,000 ## Columns: 7 ## $ title &lt;chr&gt; &quot;Guardians of the Galaxy&quot;, &quot;Prometheus&quot;, &quot;Split&quot;, &quot;Sin… ## $ director &lt;chr&gt; &quot;James Gunn&quot;, &quot;Ridley Scott&quot;, &quot;M. Night Shyamalan&quot;, &quot;C… ## $ year &lt;dbl&gt; 2014, 2012, 2016, 2016, 2016, 2016, 2016, 2016, 2016, … ## $ runtime &lt;dbl&gt; 121, 124, 117, 108, 123, 103, 128, 89, 141, 116, 133, … ## $ rating &lt;dbl&gt; 8.1, 7.0, 7.3, 7.2, 6.2, 6.1, 8.3, 6.4, 7.1, 7.0, 7.5,… ## $ votes &lt;dbl&gt; 757074, 485820, 157606, 60545, 393727, 56036, 258682, … ## $ revenue_million &lt;dbl&gt; 333.13, 126.46, 138.12, 270.32, 325.02, 45.13, 151.06,… You can also make your expressions shorter by using a couple of hacks: : can be used to select all columns between two: imdb_raw %&gt;% select(Title, Director, Year:`Revenue (Millions)`) %&gt;% rename(title = Title, director = Director, year = Year, runtime = `Runtime (Minutes)`, rating = Rating, votes = Votes, revenue_million = `Revenue (Millions)`) %&gt;% glimpse() ## Rows: 1,000 ## Columns: 7 ## $ title &lt;chr&gt; &quot;Guardians of the Galaxy&quot;, &quot;Prometheus&quot;, &quot;Split&quot;, &quot;Sin… ## $ director &lt;chr&gt; &quot;James Gunn&quot;, &quot;Ridley Scott&quot;, &quot;M. Night Shyamalan&quot;, &quot;C… ## $ year &lt;dbl&gt; 2014, 2012, 2016, 2016, 2016, 2016, 2016, 2016, 2016, … ## $ runtime &lt;dbl&gt; 121, 124, 117, 108, 123, 103, 128, 89, 141, 116, 133, … ## $ rating &lt;dbl&gt; 8.1, 7.0, 7.3, 7.2, 6.2, 6.1, 8.3, 6.4, 7.1, 7.0, 7.5,… ## $ votes &lt;dbl&gt; 757074, 485820, 157606, 60545, 393727, 56036, 258682, … ## $ revenue_million &lt;dbl&gt; 333.13, 126.46, 138.12, 270.32, 325.02, 45.13, 151.06,… starts_with() select columns whose names start with the same character string: imdb_selected &lt;- imdb_raw %&gt;% select(Title, Director, Votes, Year, starts_with(&quot;R&quot;)) %&gt;% select(-Rank) %&gt;% rename(title = Title, director = Director, year = Year, runtime = `Runtime (Minutes)`, rating = Rating, votes = Votes, revenue_million = `Revenue (Millions)`) %&gt;% glimpse() ## Rows: 1,000 ## Columns: 7 ## $ title &lt;chr&gt; &quot;Guardians of the Galaxy&quot;, &quot;Prometheus&quot;, &quot;Split&quot;, &quot;Sin… ## $ director &lt;chr&gt; &quot;James Gunn&quot;, &quot;Ridley Scott&quot;, &quot;M. Night Shyamalan&quot;, &quot;C… ## $ votes &lt;dbl&gt; 757074, 485820, 157606, 60545, 393727, 56036, 258682, … ## $ year &lt;dbl&gt; 2014, 2012, 2016, 2016, 2016, 2016, 2016, 2016, 2016, … ## $ runtime &lt;dbl&gt; 121, 124, 117, 108, 123, 103, 128, 89, 141, 116, 133, … ## $ rating &lt;dbl&gt; 8.1, 7.0, 7.3, 7.2, 6.2, 6.1, 8.3, 6.4, 7.1, 7.0, 7.5,… ## $ revenue_million &lt;dbl&gt; 333.13, 126.46, 138.12, 270.32, 325.02, 45.13, 151.06,… As you may have noticed, the order in the select() matters: columns will be ordered in the same order as they are chosen. A couple of further shortcuts for select() do exist. An overview can be found in the dplyr cheatsheet. 5.1.2 filter() Whereas select() enables you to choose variables (i.e., columns), filter() lets you choose observations (i.e., rows). In this case, I only want movies with a revenue above $100,000,000: imdb_selected %&gt;% filter(revenue_million &gt; 100) %&gt;% glimpse() ## Rows: 250 ## Columns: 7 ## $ title &lt;chr&gt; &quot;Guardians of the Galaxy&quot;, &quot;Prometheus&quot;, &quot;Split&quot;, &quot;Sin… ## $ director &lt;chr&gt; &quot;James Gunn&quot;, &quot;Ridley Scott&quot;, &quot;M. Night Shyamalan&quot;, &quot;C… ## $ votes &lt;dbl&gt; 757074, 485820, 157606, 60545, 393727, 258682, 192177,… ## $ year &lt;dbl&gt; 2014, 2012, 2016, 2016, 2016, 2016, 2016, 2016, 2016, … ## $ runtime &lt;dbl&gt; 121, 124, 117, 108, 123, 128, 116, 133, 127, 133, 107,… ## $ rating &lt;dbl&gt; 8.1, 7.0, 7.3, 7.2, 6.2, 8.3, 7.0, 7.5, 7.8, 7.9, 7.7,… ## $ revenue_million &lt;dbl&gt; 333.13, 126.46, 138.12, 270.32, 325.02, 151.06, 100.01… Besides, I am especially interested in the director Christopher Nolan. Therefore, I want to look at movies that were directed by him and made more than $100,000,000: imdb_selected %&gt;% filter(revenue_million &gt; 100 &amp; director == &quot;Christopher Nolan&quot;) %&gt;% glimpse() ## Rows: 4 ## Columns: 7 ## $ title &lt;chr&gt; &quot;Interstellar&quot;, &quot;The Dark Knight&quot;, &quot;Inception&quot;, &quot;The D… ## $ director &lt;chr&gt; &quot;Christopher Nolan&quot;, &quot;Christopher Nolan&quot;, &quot;Christopher… ## $ votes &lt;dbl&gt; 1047747, 1791916, 1583625, 1222645 ## $ year &lt;dbl&gt; 2014, 2008, 2010, 2012 ## $ runtime &lt;dbl&gt; 169, 152, 148, 164 ## $ rating &lt;dbl&gt; 8.6, 9.0, 8.8, 8.5 ## $ revenue_million &lt;dbl&gt; 187.99, 533.32, 292.57, 448.13 The following overview is taken from the dplyr cheatsheet and shows the operators you can use in filter(): Overview of comparison operators 5.1.2.1 Exemplary application To demonstrate how a real-world application of this stuff could look like, I will now provide you a brief insight into my private life and how I organize movie nights. JK. You could definitely try this at home and surprise your loved ones with such hot applications. If you are brave and surprise your latest Tinder match with an .RDS file containing suggestions for Netflix&amp;Chill, please let me know what their response looked like. Tonight, I will hang out with a real nerd. Probably because they (nerds have all kinds of genders) know about my faible for R, they have sent me a vector containing a couple of movies we could watch tonight: set.seed(123) # guarantees that movie_vec will always be the same thing movie_vec &lt;- imdb_raw$Title[sample(1000, 10, replace = FALSE)] movie_vec ## [1] &quot;Mechanic: Resurrection&quot; &quot;Denial&quot; &quot;The Conjuring 2&quot; ## [4] &quot;Birth of the Dragon&quot; &quot;Warrior&quot; &quot;Super&quot; ## [7] &quot;127 Hours&quot; &quot;Dangal&quot; &quot;The Infiltrator&quot; ## [10] &quot;Maleficent&quot; However, I want to make a more informed decision and decide to obtain some more information on the movies from my IMDb data set: imdb_selected %&gt;% filter(title %in% movie_vec) %&gt;% glimpse() ## Rows: 10 ## Columns: 7 ## $ title &lt;chr&gt; &quot;Dangal&quot;, &quot;The Conjuring 2&quot;, &quot;Warrior&quot;, &quot;Maleficent&quot;, … ## $ director &lt;chr&gt; &quot;Nitesh Tiwari&quot;, &quot;James Wan&quot;, &quot;Gavin O&#39;Connor&quot;, &quot;Rober… ## $ votes &lt;dbl&gt; 48969, 137203, 355722, 268877, 43929, 48161, 8229, 552… ## $ year &lt;dbl&gt; 2016, 2016, 2011, 2014, 2016, 2016, 2016, 2016, 2010, … ## $ runtime &lt;dbl&gt; 161, 134, 140, 97, 127, 98, 109, 103, 94, 96 ## $ rating &lt;dbl&gt; 8.8, 7.4, 8.2, 7.0, 7.1, 5.6, 6.6, 3.9, 7.6, 6.8 ## $ revenue_million &lt;dbl&gt; 11.15, 102.46, 13.65, 241.41, 15.43, 21.20, 4.07, 93.0… I have convinced them to watch either one of the movies they have suggested or one directed by Christopher Nolan or one with a rating greater or equal to 8.5 and send them back this data set: imdb_selected %&gt;% filter(title %in% movie_vec | director == &quot;Christopher Nolan&quot; | rating &gt;= 8.5) %&gt;% glimpse() ## Rows: 21 ## Columns: 7 ## $ title &lt;chr&gt; &quot;Interstellar&quot;, &quot;The Dark Knight&quot;, &quot;The Prestige&quot;, &quot;In… ## $ director &lt;chr&gt; &quot;Christopher Nolan&quot;, &quot;Christopher Nolan&quot;, &quot;Christopher… ## $ votes &lt;dbl&gt; 1047747, 1791916, 913152, 1583625, 34110, 937414, 4896… ## $ year &lt;dbl&gt; 2014, 2008, 2006, 2010, 2016, 2006, 2016, 2012, 2014, … ## $ runtime &lt;dbl&gt; 169, 152, 130, 148, 106, 151, 161, 164, 107, 134, 140,… ## $ rating &lt;dbl&gt; 8.6, 9.0, 8.5, 8.8, 8.6, 8.5, 8.8, 8.5, 8.5, 7.4, 8.2,… ## $ revenue_million &lt;dbl&gt; 187.99, 533.32, 53.08, 292.57, 4.68, 132.37, 11.15, 44… “I deteste ‘Interstellar,’” is the response. “All right,” I say to myself, “I can easily exclude it.” imdb_selected %&gt;% filter(title %in% movie_vec | director == &quot;Christopher Nolan&quot; | rating &gt;= 8.5 &amp; title != &quot;Interstellar&quot;) %&gt;% # if you want to negate something, put the ! in front of it glimpse() ## Rows: 21 ## Columns: 7 ## $ title &lt;chr&gt; &quot;Interstellar&quot;, &quot;The Dark Knight&quot;, &quot;The Prestige&quot;, &quot;In… ## $ director &lt;chr&gt; &quot;Christopher Nolan&quot;, &quot;Christopher Nolan&quot;, &quot;Christopher… ## $ votes &lt;dbl&gt; 1047747, 1791916, 913152, 1583625, 34110, 937414, 4896… ## $ year &lt;dbl&gt; 2014, 2008, 2006, 2010, 2016, 2006, 2016, 2012, 2014, … ## $ runtime &lt;dbl&gt; 169, 152, 130, 148, 106, 151, 161, 164, 107, 134, 140,… ## $ rating &lt;dbl&gt; 8.6, 9.0, 8.5, 8.8, 8.6, 8.5, 8.8, 8.5, 8.5, 7.4, 8.2,… ## $ revenue_million &lt;dbl&gt; 187.99, 533.32, 53.08, 292.57, 4.68, 132.37, 11.15, 44… Oh, that did not work. I should wrap them in columns: imdb_selected %&gt;% filter((title %in% movie_vec | director == &quot;Christopher Nolan&quot; | rating &gt;= 8.5) &amp; title != &quot;Interstellar&quot;) %&gt;% glimpse() ## Rows: 20 ## Columns: 7 ## $ title &lt;chr&gt; &quot;The Dark Knight&quot;, &quot;The Prestige&quot;, &quot;Inception&quot;, &quot;Kimi … ## $ director &lt;chr&gt; &quot;Christopher Nolan&quot;, &quot;Christopher Nolan&quot;, &quot;Christopher… ## $ votes &lt;dbl&gt; 1791916, 913152, 1583625, 34110, 937414, 48969, 122264… ## $ year &lt;dbl&gt; 2008, 2006, 2010, 2016, 2006, 2016, 2012, 2014, 2016, … ## $ runtime &lt;dbl&gt; 152, 130, 148, 106, 151, 161, 164, 107, 134, 140, 97, … ## $ rating &lt;dbl&gt; 9.0, 8.5, 8.8, 8.6, 8.5, 8.8, 8.5, 8.5, 7.4, 8.2, 7.0,… ## $ revenue_million &lt;dbl&gt; 533.32, 53.08, 292.57, 4.68, 132.37, 11.15, 448.13, 13… They come up with a new idea: we have a Scottish evening with a movie directed by the Scottish director Gillies MacKinnon: imdb_selected %&gt;% filter(director == &quot;Gillies MacKinnon&quot;) %&gt;% glimpse() ## Rows: 1 ## Columns: 7 ## $ title &lt;chr&gt; &quot;Whisky Galore&quot; ## $ director &lt;chr&gt; &quot;Gillies MacKinnon&quot; ## $ votes &lt;dbl&gt; 102 ## $ year &lt;dbl&gt; 2016 ## $ runtime &lt;dbl&gt; 98 ## $ rating &lt;dbl&gt; 5 ## $ revenue_million &lt;dbl&gt; NA “Well, apparently there is a problem in the data set,” I notice. “There is an NA in the revenue column. I should probably have a further look at this.” imdb_selected %&gt;% filter(is.na(revenue_million)) %&gt;% glimpse() ## Rows: 128 ## Columns: 7 ## $ title &lt;chr&gt; &quot;Mindhorn&quot;, &quot;Hounds of Love&quot;, &quot;Paris pieds nus&quot;, &quot;5- 2… ## $ director &lt;chr&gt; &quot;Sean Foley&quot;, &quot;Ben Young&quot;, &quot;Dominique Abel&quot;, &quot;Patrick … ## $ votes &lt;dbl&gt; 2490, 1115, 222, 241, 496, 5103, 987, 35870, 149791, 7… ## $ year &lt;dbl&gt; 2016, 2016, 2016, 2007, 2016, 2016, 2016, 2016, 2016, … ## $ runtime &lt;dbl&gt; 89, 108, 83, 113, 73, 91, 130, 86, 133, 106, 105, 118,… ## $ rating &lt;dbl&gt; 6.4, 6.7, 6.8, 7.1, 2.7, 5.6, 3.7, 6.8, 5.9, 7.9, 5.8,… ## $ revenue_million &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA… Well, that’s quite a significant number of NAs. I will need to exclude these cases: imdb_selected %&gt;% filter(!is.na(revenue_million)) %&gt;% glimpse() ## Rows: 872 ## Columns: 7 ## $ title &lt;chr&gt; &quot;Guardians of the Galaxy&quot;, &quot;Prometheus&quot;, &quot;Split&quot;, &quot;Sin… ## $ director &lt;chr&gt; &quot;James Gunn&quot;, &quot;Ridley Scott&quot;, &quot;M. Night Shyamalan&quot;, &quot;C… ## $ votes &lt;dbl&gt; 757074, 485820, 157606, 60545, 393727, 56036, 258682, … ## $ year &lt;dbl&gt; 2014, 2012, 2016, 2016, 2016, 2016, 2016, 2016, 2016, … ## $ runtime &lt;dbl&gt; 121, 124, 117, 108, 123, 103, 128, 141, 116, 133, 127,… ## $ rating &lt;dbl&gt; 8.1, 7.0, 7.3, 7.2, 6.2, 6.1, 8.3, 7.1, 7.0, 7.5, 7.8,… ## $ revenue_million &lt;dbl&gt; 333.13, 126.46, 138.12, 270.32, 325.02, 45.13, 151.06,… 5.1.2.2 Other possibilities to subset observations slice() selects rows by positions: imdb_selected %&gt;% slice(1:10) %&gt;% glimpse() ## Rows: 10 ## Columns: 7 ## $ title &lt;chr&gt; &quot;Guardians of the Galaxy&quot;, &quot;Prometheus&quot;, &quot;Split&quot;, &quot;Sin… ## $ director &lt;chr&gt; &quot;James Gunn&quot;, &quot;Ridley Scott&quot;, &quot;M. Night Shyamalan&quot;, &quot;C… ## $ votes &lt;dbl&gt; 757074, 485820, 157606, 60545, 393727, 56036, 258682, … ## $ year &lt;dbl&gt; 2014, 2012, 2016, 2016, 2016, 2016, 2016, 2016, 2016, … ## $ runtime &lt;dbl&gt; 121, 124, 117, 108, 123, 103, 128, 89, 141, 116 ## $ rating &lt;dbl&gt; 8.1, 7.0, 7.3, 7.2, 6.2, 6.1, 8.3, 6.4, 7.1, 7.0 ## $ revenue_million &lt;dbl&gt; 333.13, 126.46, 138.12, 270.32, 325.02, 45.13, 151.06,… distinct removes duplicate rows: imdb_selected %&gt;% distinct(director) %&gt;% glimpse() ## Rows: 644 ## Columns: 1 ## $ director &lt;chr&gt; &quot;James Gunn&quot;, &quot;Ridley Scott&quot;, &quot;M. Night Shyamalan&quot;, &quot;Christop… By default, it will remove all other columns apart from the one(s) you have specified. You can avoid that by setting .keep_all = TRUE: imdb_selected %&gt;% distinct(title, .keep_all = TRUE) %&gt;% glimpse() ## Rows: 999 ## Columns: 7 ## $ title &lt;chr&gt; &quot;Guardians of the Galaxy&quot;, &quot;Prometheus&quot;, &quot;Split&quot;, &quot;Sin… ## $ director &lt;chr&gt; &quot;James Gunn&quot;, &quot;Ridley Scott&quot;, &quot;M. Night Shyamalan&quot;, &quot;C… ## $ votes &lt;dbl&gt; 757074, 485820, 157606, 60545, 393727, 56036, 258682, … ## $ year &lt;dbl&gt; 2014, 2012, 2016, 2016, 2016, 2016, 2016, 2016, 2016, … ## $ runtime &lt;dbl&gt; 121, 124, 117, 108, 123, 103, 128, 89, 141, 116, 133, … ## $ rating &lt;dbl&gt; 8.1, 7.0, 7.3, 7.2, 6.2, 6.1, 8.3, 6.4, 7.1, 7.0, 7.5,… ## $ revenue_million &lt;dbl&gt; 333.13, 126.46, 138.12, 270.32, 325.02, 45.13, 151.06,… Oh, interesting, there is apparently one movie which is in there twice. How could we find this movie? 5.1.3 mutate() My data set looks pretty nice already, but one flaw catches the eye: the column revenue_million should probably be converted to revenue. Hence, I need to create a new variable which contains the values from revenue_million multiplied by 1,000,000 and drop the now obsolete revenue_million. imdb_selected %&gt;% mutate(revenue = revenue_million * 1000000) %&gt;% select(-revenue_million) %&gt;% glimpse() ## Rows: 1,000 ## Columns: 7 ## $ title &lt;chr&gt; &quot;Guardians of the Galaxy&quot;, &quot;Prometheus&quot;, &quot;Split&quot;, &quot;Sing&quot;, &quot;Su… ## $ director &lt;chr&gt; &quot;James Gunn&quot;, &quot;Ridley Scott&quot;, &quot;M. Night Shyamalan&quot;, &quot;Christop… ## $ votes &lt;dbl&gt; 757074, 485820, 157606, 60545, 393727, 56036, 258682, 2490, 7… ## $ year &lt;dbl&gt; 2014, 2012, 2016, 2016, 2016, 2016, 2016, 2016, 2016, 2016, 2… ## $ runtime &lt;dbl&gt; 121, 124, 117, 108, 123, 103, 128, 89, 141, 116, 133, 127, 13… ## $ rating &lt;dbl&gt; 8.1, 7.0, 7.3, 7.2, 6.2, 6.1, 8.3, 6.4, 7.1, 7.0, 7.5, 7.8, 7… ## $ revenue &lt;dbl&gt; 333130000, 126460000, 138120000, 270320000, 325020000, 451300… The structure of the mutate() call looks like this: first, you need to provide the name of the new variable. If the variable exists already, it will be replaced. Second, the equal sign tells R what the new variable should contain. Third, a function that outputs a vector which is as long as the tibble has rows or 1. If we want to drop all other columns and just keep the new one: transmute() drops all the original columns. imdb_selected %&gt;% transmute(revenue = revenue_million * 1000000) %&gt;% glimpse() ## Rows: 1,000 ## Columns: 1 ## $ revenue &lt;dbl&gt; 333130000, 126460000, 138120000, 270320000, 325020000, 4513000… mutate() uses so-called window functions. They take one vector of values and return another vector of values. An overview – again, from the cheat sheet: Window functions Another feature of dplyr, which is useful in combination with mutate(), is case_when(). case_when() can for instance be used to create binary indicator variables. In this example I want it to be 0 if the movie was made before 2010 and 1 if not. imdb_selected %&gt;% mutate(indicator = case_when(year &lt; 2010 ~ 0, year &gt;= 2010 ~ 1, TRUE ~ 2)) %&gt;% glimpse() ## Rows: 1,000 ## Columns: 8 ## $ title &lt;chr&gt; &quot;Guardians of the Galaxy&quot;, &quot;Prometheus&quot;, &quot;Split&quot;, &quot;Sin… ## $ director &lt;chr&gt; &quot;James Gunn&quot;, &quot;Ridley Scott&quot;, &quot;M. Night Shyamalan&quot;, &quot;C… ## $ votes &lt;dbl&gt; 757074, 485820, 157606, 60545, 393727, 56036, 258682, … ## $ year &lt;dbl&gt; 2014, 2012, 2016, 2016, 2016, 2016, 2016, 2016, 2016, … ## $ runtime &lt;dbl&gt; 121, 124, 117, 108, 123, 103, 128, 89, 141, 116, 133, … ## $ rating &lt;dbl&gt; 8.1, 7.0, 7.3, 7.2, 6.2, 6.1, 8.3, 6.4, 7.1, 7.0, 7.5,… ## $ revenue_million &lt;dbl&gt; 333.13, 126.46, 138.12, 270.32, 325.02, 45.13, 151.06,… ## $ indicator &lt;dbl&gt; 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, … Keep in mind that you can throw any function into mutate() as long as it is vectorized and the output has the same length as the tibble or 1. 5.1.4 summarize() and group_by When you analyze data, you often want to compare entities according to some sort of summary statistic. This means that you, first, need to split up your data set into certain groups which share one or more characteristics, and, second, collapse the columns together into single-row summaries. The former challenge is accomplished using group_by() whose argument is one or more variables, the latter requires the summarize() function. This function works similar to mutate() but uses summary functions – which take a vector of multiple values and return a single value – instead of window functions – which return a vector of the same length as the input. Let me provide you an example. I am interested in the director’s average ratings: imdb_selected %&gt;% group_by(director) %&gt;% summarize(avg_rating = mean(rating)) ## # A tibble: 644 × 2 ## director avg_rating ## &lt;chr&gt; &lt;dbl&gt; ## 1 Aamir Khan 8.5 ## 2 Abdellatif Kechiche 7.8 ## 3 Adam Leon 6.5 ## 4 Adam McKay 7 ## 5 Adam Shankman 6.3 ## 6 Adam Wingard 5.9 ## 7 Afonso Poyart 6.4 ## 8 Aisling Walsh 7.8 ## 9 Akan Satayev 6.3 ## 10 Akiva Schaffer 6.7 ## # … with 634 more rows In general, summarize() always works like this: first, you change the scope from the entire tibble to different groups. Then, you calculate your summary. If you then want to further manipulate your date or calculate something else based on the new summary, you need to call ungroup(). You can see the summary functions below: Summary functions in R Another handy function akin to this is count(). It counts all occurrences of a singular value in the tibble. If I were interested in how many movies of the different directors have made it into the data set, I could use this code: imdb_selected %&gt;% count(director) ## # A tibble: 644 × 2 ## director n ## &lt;chr&gt; &lt;int&gt; ## 1 Aamir Khan 1 ## 2 Abdellatif Kechiche 1 ## 3 Adam Leon 1 ## 4 Adam McKay 4 ## 5 Adam Shankman 2 ## 6 Adam Wingard 2 ## 7 Afonso Poyart 1 ## 8 Aisling Walsh 1 ## 9 Akan Satayev 1 ## 10 Akiva Schaffer 1 ## # … with 634 more rows Beyond that, you can also use group_by() with mutate. If you do so, the rows will not be collapsed together as in summarize(). 5.1.5 arrange() Finally, you can also sort values using arrange(). In the last section, I was interested in directors’ respective average ratings. The values were ordered according to their name (hence, “Aamir Khan” was first). In this case, the order dos not make too much sense, because the first name does not say too much about the director’s ratings. Therefore, I want to sort them according to their average ratings: imdb_selected %&gt;% group_by(director) %&gt;% summarize(avg_rating = mean(rating)) %&gt;% arrange(avg_rating) ## # A tibble: 644 × 2 ## director avg_rating ## &lt;chr&gt; &lt;dbl&gt; ## 1 Jason Friedberg 1.9 ## 2 James Wong 2.7 ## 3 Shawn Burkett 2.7 ## 4 Jonathan Holbrook 3.2 ## 5 Femi Oyeniran 3.5 ## 6 Micheal Bafaro 3.5 ## 7 Jeffrey G. Hunt 3.7 ## 8 Rolfe Kanefsky 3.9 ## 9 Joey Curtis 4 ## 10 Sam Taylor-Johnson 4.1 ## # … with 634 more rows All right, Jason Friedberg is apparently the director of the worst rated movie in my data set. But it would be more handy, if they were arranged in descending order. I can use desc() for this: imdb_selected %&gt;% group_by(director) %&gt;% summarize(avg_rating = mean(rating)) %&gt;% arrange(-avg_rating) ## # A tibble: 644 × 2 ## director avg_rating ## &lt;chr&gt; &lt;dbl&gt; ## 1 Nitesh Tiwari 8.8 ## 2 Christopher Nolan 8.68 ## 3 Makoto Shinkai 8.6 ## 4 Olivier Nakache 8.6 ## 5 Aamir Khan 8.5 ## 6 Florian Henckel von Donnersmarck 8.5 ## 7 Damien Chazelle 8.4 ## 8 Naoko Yamada 8.4 ## 9 Amber Tamblyn 8.3 ## 10 Lee Unkrich 8.3 ## # … with 634 more rows Chapeau, Nitesh Tiwari! 5.2 Introducing joins The last session showed you three things: how you get data sets into R, a couple of ways to create tibbles, and an introduction to tidy data and how to make data sets tidy using the tidyr package. As you may recall from the last session, it was not able to solve the last two problems with only the tools tidyr offers. In particular, the problems were: Multiple types of observational units are stored in the same table. A single observational unit is stored in multiple tables. Both problems need some different kind of tools: joins. Joins can be used to merge tibbles together. This tutorial, again, builds heavy on the R for Data Science book (Wickham and Grolemund 2016) 5.2.1 Multiple types of units are in the same table Let’s look at the following data set. It contains the billboard charts in 2000 and was obtained from the tidyr GitHub repo. The example below is taken from the tidyr vignette which can be loaded using vignette(\"tidy-data\", package = \"tidyr\"). library(tidyverse) library(lubridate) load(&quot;data/billboard.rda&quot;) glimpse(billboard) ## Rows: 317 ## Columns: 79 ## $ artist &lt;chr&gt; &quot;2 Pac&quot;, &quot;2Ge+her&quot;, &quot;3 Doors Down&quot;, &quot;3 Doors Down&quot;, &quot;504 … ## $ track &lt;chr&gt; &quot;Baby Don&#39;t Cry (Keep...&quot;, &quot;The Hardest Part Of ...&quot;, &quot;Kr… ## $ date.entered &lt;date&gt; 2000-02-26, 2000-09-02, 2000-04-08, 2000-10-21, 2000-04-… ## $ wk1 &lt;dbl&gt; 87, 91, 81, 76, 57, 51, 97, 84, 59, 76, 84, 57, 50, 71, 7… ## $ wk2 &lt;dbl&gt; 82, 87, 70, 76, 34, 39, 97, 62, 53, 76, 84, 47, 39, 51, 6… ## $ wk3 &lt;dbl&gt; 72, 92, 68, 72, 25, 34, 96, 51, 38, 74, 75, 45, 30, 28, 5… ## $ wk4 &lt;dbl&gt; 77, NA, 67, 69, 17, 26, 95, 41, 28, 69, 73, 29, 28, 18, 4… ## $ wk5 &lt;dbl&gt; 87, NA, 66, 67, 17, 26, 100, 38, 21, 68, 73, 23, 21, 13, … ## $ wk6 &lt;dbl&gt; 94, NA, 57, 65, 31, 19, NA, 35, 18, 67, 69, 18, 19, 13, 3… ## $ wk7 &lt;dbl&gt; 99, NA, 54, 55, 36, 2, NA, 35, 16, 61, 68, 11, 20, 11, 34… ## $ wk8 &lt;dbl&gt; NA, NA, 53, 59, 49, 2, NA, 38, 14, 58, 65, 9, 17, 1, 29, … ## $ wk9 &lt;dbl&gt; NA, NA, 51, 62, 53, 3, NA, 38, 12, 57, 73, 9, 17, 1, 27, … ## $ wk10 &lt;dbl&gt; NA, NA, 51, 61, 57, 6, NA, 36, 10, 59, 83, 11, 17, 2, 30,… ## $ wk11 &lt;dbl&gt; NA, NA, 51, 61, 64, 7, NA, 37, 9, 66, 92, 1, 17, 2, 36, N… ## $ wk12 &lt;dbl&gt; NA, NA, 51, 59, 70, 22, NA, 37, 8, 68, NA, 1, 3, 3, 37, N… ## $ wk13 &lt;dbl&gt; NA, NA, 47, 61, 75, 29, NA, 38, 6, 61, NA, 1, 3, 3, 39, N… ## $ wk14 &lt;dbl&gt; NA, NA, 44, 66, 76, 36, NA, 49, 1, 67, NA, 1, 7, 4, 49, N… ## $ wk15 &lt;dbl&gt; NA, NA, 38, 72, 78, 47, NA, 61, 2, 59, NA, 4, 10, 12, 57,… ## $ wk16 &lt;dbl&gt; NA, NA, 28, 76, 85, 67, NA, 63, 2, 63, NA, 8, 17, 11, 63,… ## $ wk17 &lt;dbl&gt; NA, NA, 22, 75, 92, 66, NA, 62, 2, 67, NA, 12, 25, 13, 65… ## $ wk18 &lt;dbl&gt; NA, NA, 18, 67, 96, 84, NA, 67, 2, 71, NA, 22, 29, 15, 68… ## $ wk19 &lt;dbl&gt; NA, NA, 18, 73, NA, 93, NA, 83, 3, 79, NA, 23, 29, 18, 79… ## $ wk20 &lt;dbl&gt; NA, NA, 14, 70, NA, 94, NA, 86, 4, 89, NA, 43, 40, 20, 86… ## $ wk21 &lt;dbl&gt; NA, NA, 12, NA, NA, NA, NA, NA, 5, NA, NA, 44, 43, 30, NA… ## $ wk22 &lt;dbl&gt; NA, NA, 7, NA, NA, NA, NA, NA, 5, NA, NA, NA, 50, 40, NA,… ## $ wk23 &lt;dbl&gt; NA, NA, 6, NA, NA, NA, NA, NA, 6, NA, NA, NA, NA, 39, NA,… ## $ wk24 &lt;dbl&gt; NA, NA, 6, NA, NA, NA, NA, NA, 9, NA, NA, NA, NA, 44, NA,… ## $ wk25 &lt;dbl&gt; NA, NA, 6, NA, NA, NA, NA, NA, 13, NA, NA, NA, NA, NA, NA… ## $ wk26 &lt;dbl&gt; NA, NA, 5, NA, NA, NA, NA, NA, 14, NA, NA, NA, NA, NA, NA… ## $ wk27 &lt;dbl&gt; NA, NA, 5, NA, NA, NA, NA, NA, 16, NA, NA, NA, NA, NA, NA… ## $ wk28 &lt;dbl&gt; NA, NA, 4, NA, NA, NA, NA, NA, 23, NA, NA, NA, NA, NA, NA… ## $ wk29 &lt;dbl&gt; NA, NA, 4, NA, NA, NA, NA, NA, 22, NA, NA, NA, NA, NA, NA… ## $ wk30 &lt;dbl&gt; NA, NA, 4, NA, NA, NA, NA, NA, 33, NA, NA, NA, NA, NA, NA… ## $ wk31 &lt;dbl&gt; NA, NA, 4, NA, NA, NA, NA, NA, 36, NA, NA, NA, NA, NA, NA… ## $ wk32 &lt;dbl&gt; NA, NA, 3, NA, NA, NA, NA, NA, 43, NA, NA, NA, NA, NA, NA… ## $ wk33 &lt;dbl&gt; NA, NA, 3, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA… ## $ wk34 &lt;dbl&gt; NA, NA, 3, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA… ## $ wk35 &lt;dbl&gt; NA, NA, 4, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA… ## $ wk36 &lt;dbl&gt; NA, NA, 5, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA… ## $ wk37 &lt;dbl&gt; NA, NA, 5, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA… ## $ wk38 &lt;dbl&gt; NA, NA, 9, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA… ## $ wk39 &lt;dbl&gt; NA, NA, 9, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA… ## $ wk40 &lt;dbl&gt; NA, NA, 15, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, N… ## $ wk41 &lt;dbl&gt; NA, NA, 14, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, N… ## $ wk42 &lt;dbl&gt; NA, NA, 13, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, N… ## $ wk43 &lt;dbl&gt; NA, NA, 14, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, N… ## $ wk44 &lt;dbl&gt; NA, NA, 16, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, N… ## $ wk45 &lt;dbl&gt; NA, NA, 17, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, N… ## $ wk46 &lt;dbl&gt; NA, NA, 21, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, N… ## $ wk47 &lt;dbl&gt; NA, NA, 22, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, N… ## $ wk48 &lt;dbl&gt; NA, NA, 24, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, N… ## $ wk49 &lt;dbl&gt; NA, NA, 28, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, N… ## $ wk50 &lt;dbl&gt; NA, NA, 33, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, N… ## $ wk51 &lt;dbl&gt; NA, NA, 42, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, N… ## $ wk52 &lt;dbl&gt; NA, NA, 42, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, N… ## $ wk53 &lt;dbl&gt; NA, NA, 49, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, N… ## $ wk54 &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, N… ## $ wk55 &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, N… ## $ wk56 &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, N… ## $ wk57 &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, N… ## $ wk58 &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, N… ## $ wk59 &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, N… ## $ wk60 &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, N… ## $ wk61 &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, N… ## $ wk62 &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, N… ## $ wk63 &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, N… ## $ wk64 &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, N… ## $ wk65 &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, N… ## $ wk66 &lt;lgl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, N… ## $ wk67 &lt;lgl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, N… ## $ wk68 &lt;lgl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, N… ## $ wk69 &lt;lgl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, N… ## $ wk70 &lt;lgl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, N… ## $ wk71 &lt;lgl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, N… ## $ wk72 &lt;lgl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, N… ## $ wk73 &lt;lgl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, N… ## $ wk74 &lt;lgl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, N… ## $ wk75 &lt;lgl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, N… ## $ wk76 &lt;lgl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, N… Here, you can immediately see the problem: it contains two types of observations: songs and ranks. Hence, the data set needs to be split up. However, there should be a pointer from the rank data set to the song data set. First, I add an ID column to song_tbl. Then, I can add it to rank_tbl and drop the unnecessary columns which contain the name of the artist and the track. song_tbl &lt;- billboard %&gt;% distinct(artist, track) %&gt;% mutate(song_id = row_number()) glimpse(song_tbl) ## Rows: 317 ## Columns: 3 ## $ artist &lt;chr&gt; &quot;2 Pac&quot;, &quot;2Ge+her&quot;, &quot;3 Doors Down&quot;, &quot;3 Doors Down&quot;, &quot;504 Boyz&quot;… ## $ track &lt;chr&gt; &quot;Baby Don&#39;t Cry (Keep...&quot;, &quot;The Hardest Part Of ...&quot;, &quot;Krypton… ## $ song_id &lt;int&gt; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18,… rank_tbl &lt;- billboard %&gt;% pivot_longer(cols = starts_with(&quot;wk&quot;), names_to = &quot;week&quot;, names_prefix = &quot;wk&quot;, values_to = &quot;rank&quot;) %&gt;% mutate(week = as.numeric(week), date = date.entered + (week-1) * 7) %&gt;% drop_na() %&gt;% left_join(song_tbl, by = c(&quot;artist&quot;, &quot;track&quot;)) %&gt;% select(song_id, date, week, rank) glimpse(rank_tbl) ## Rows: 5,307 ## Columns: 4 ## $ song_id &lt;int&gt; 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,… ## $ date &lt;date&gt; 2000-02-26, 2000-03-04, 2000-03-11, 2000-03-18, 2000-03-25, 2… ## $ week &lt;dbl&gt; 1, 2, 3, 4, 5, 6, 7, 1, 2, 3, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 1… ## $ rank &lt;dbl&gt; 87, 82, 72, 77, 87, 94, 99, 91, 87, 92, 81, 70, 68, 67, 66, 57… 5.2.2 One unit is in multiple tables For this example, I have split up a data set from the socviz package containing data on the 2016 elections in the U.S. according to census region and stored them in a folder. I can scrape the file names in the folder and read it into a list in an automated manner. You will learn this when we touch upon iteration. library(fs) file_list &lt;- dir_ls(path = &quot;data/socviz_us&quot;) %&gt;% map(read_csv, col_types = cols( id = col_double(), name = col_character(), state = col_character(), census_region = col_character(), pop_dens = col_character(), pop_dens4 = col_character(), pop_dens6 = col_character(), pct_black = col_character(), pop = col_double(), female = col_double(), white = col_double(), black = col_double(), travel_time = col_double(), land_area = col_double(), hh_income = col_double(), su_gun4 = col_character(), su_gun6 = col_character(), fips = col_double(), votes_dem_2016 = col_double(), votes_gop_2016 = col_double(), total_votes_2016 = col_double(), per_dem_2016 = col_double(), per_gop_2016 = col_double(), diff_2016 = col_double(), per_dem_2012 = col_double(), per_gop_2012 = col_double(), diff_2012 = col_double(), winner = col_character(), partywinner16 = col_character(), winner12 = col_character(), partywinner12 = col_character(), flipped = col_character() )) The list now consists of four tibbles which need to be bound together. You can achieve this using bind_rows(). Its counterpart is bind_cols() which binds columns together. It matches rows by position. election_data &lt;- file_list %&gt;% bind_rows() glimpse(election_data) ## Rows: 3,141 ## Columns: 32 ## $ id &lt;dbl&gt; 17001, 17003, 17005, 17007, 17009, 17011, 17013, 1701… ## $ name &lt;chr&gt; &quot;Adams County&quot;, &quot;Alexander County&quot;, &quot;Bond County&quot;, &quot;B… ## $ state &lt;chr&gt; &quot;IL&quot;, &quot;IL&quot;, &quot;IL&quot;, &quot;IL&quot;, &quot;IL&quot;, &quot;IL&quot;, &quot;IL&quot;, &quot;IL&quot;, &quot;IL&quot;,… ## $ census_region &lt;chr&gt; &quot;Midwest&quot;, &quot;Midwest&quot;, &quot;Midwest&quot;, &quot;Midwest&quot;, &quot;Midwest&quot;… ## $ pop_dens &lt;chr&gt; &quot;[ 50, 100)&quot;, &quot;[ 10, 50)&quot;, &quot;[ 10, 50)&quot;, &quot;[… ## $ pop_dens4 &lt;chr&gt; &quot;[ 45, 118)&quot;, &quot;[ 17, 45)&quot;, &quot;[ 45, 118)&quot;, &quot;[118,71… ## $ pop_dens6 &lt;chr&gt; &quot;[ 45, 82)&quot;, &quot;[ 25, 45)&quot;, &quot;[ 45, 82)&quot;, &quot;[ 82, … ## $ pct_black &lt;chr&gt; &quot;[ 2.0, 5.0)&quot;, &quot;[25.0,50.0)&quot;, &quot;[ 5.0,10.0)&quot;, &quot;[ 2.0, … ## $ pop &lt;dbl&gt; 66988, 7492, 17269, 53869, 6832, 33840, 4956, 14715, … ## $ female &lt;dbl&gt; 51.3, 49.5, 47.5, 50.2, 35.5, 51.0, 49.7, 50.1, 49.1,… ## $ white &lt;dbl&gt; 93.7, 60.6, 90.9, 93.2, 78.6, 96.8, 98.8, 96.7, 93.2,… ## $ black &lt;dbl&gt; 3.7, 36.1, 6.5, 2.6, 19.1, 0.8, 0.3, 1.1, 4.4, 12.8, … ## $ travel_time &lt;dbl&gt; 16.6, 25.6, 23.6, 30.1, 18.9, 20.4, 39.6, 23.8, 22.2,… ## $ land_area &lt;dbl&gt; 855.20, 235.51, 380.28, 280.72, 305.61, 869.03, 253.8… ## $ hh_income &lt;dbl&gt; 45073, 26972, 48163, 60893, 42194, 48977, 50436, 4798… ## $ su_gun4 &lt;chr&gt; &quot;[ 0, 5)&quot;, &quot;[ 5, 8)&quot;, &quot;[ 0, 5)&quot;, &quot;[ 0, 5)&quot;, &quot;[ 0, 5)&quot;… ## $ su_gun6 &lt;chr&gt; &quot;[ 4, 7)&quot;, &quot;[ 7, 8)&quot;, &quot;[ 4, 7)&quot;, &quot;[ 0, 4)&quot;, &quot;[ 0, 4)&quot;… ## $ fips &lt;dbl&gt; 17001, 17003, 17005, 17007, 17009, 17011, 17013, 1701… ## $ votes_dem_2016 &lt;dbl&gt; 7633, 1262, 2066, 8952, 475, 6010, 739, 2437, 1617, 4… ## $ votes_gop_2016 &lt;dbl&gt; 22732, 1496, 4884, 12261, 1776, 9264, 1719, 4428, 321… ## $ total_votes_2016 &lt;dbl&gt; 31770, 2820, 7462, 22604, 2336, 16303, 2556, 7354, 50… ## $ per_dem_2016 &lt;dbl&gt; 0.2402581, 0.4475177, 0.2768695, 0.3960361, 0.2033390… ## $ per_gop_2016 &lt;dbl&gt; 0.7155178, 0.5304965, 0.6545162, 0.5424261, 0.7602740… ## $ diff_2016 &lt;dbl&gt; 15099, 234, 2818, 3309, 1301, 3254, 980, 1991, 1599, … ## $ per_dem_2012 &lt;dbl&gt; 0.3152466, 0.5610873, 0.4122471, 0.4625697, 0.3331922… ## $ per_gop_2012 &lt;dbl&gt; 0.6670705, 0.4248927, 0.5591853, 0.5195706, 0.6397121… ## $ diff_2012 &lt;dbl&gt; 10744, 476, 1075, 1216, 724, 33, 360, 107, 657, 5292,… ## $ winner &lt;chr&gt; &quot;Trump&quot;, &quot;Trump&quot;, &quot;Trump&quot;, &quot;Trump&quot;, &quot;Trump&quot;, &quot;Trump&quot;,… ## $ partywinner16 &lt;chr&gt; &quot;Republican&quot;, &quot;Republican&quot;, &quot;Republican&quot;, &quot;Republican… ## $ winner12 &lt;chr&gt; &quot;Romney&quot;, &quot;Obama&quot;, &quot;Romney&quot;, &quot;Romney&quot;, &quot;Romney&quot;, &quot;Rom… ## $ partywinner12 &lt;chr&gt; &quot;Republican&quot;, &quot;Democrat&quot;, &quot;Republican&quot;, &quot;Republican&quot;,… ## $ flipped &lt;chr&gt; &quot;No&quot;, &quot;Yes&quot;, &quot;No&quot;, &quot;No&quot;, &quot;No&quot;, &quot;No&quot;, &quot;No&quot;, &quot;Yes&quot;, &quot;No… Now, the data set is ready for cleaning and tidying. Feel free to do this is as a take-home exercise. However, the topic of this script is different joins. The dplyr package offers six different joins: left_join(), right_join(), inner_join(), full_join(), semi_join(), and anti_join(). The former four are mutating joins, they add columns. The latter two can be used to filter rows in a data set. Below is an overview from the dplyr cheat sheet: Overview of the different joins In the following, I will illustrate this using the election data. I split up the data set into three: data on the elections 2016 and 2012, and demographic data. The column they have in common is the county’s respective name. election_data16 &lt;- election_data %&gt;% select(name, state, votes_dem_2016:diff_2016, winner, partywinner16) election_data12 &lt;- election_data %&gt;% select(name, state, per_dem_2012:partywinner12) demographic_data &lt;- election_data %&gt;% select(name, state, pop:hh_income) %&gt;% slice(1:2000) 5.2.3 left_join() and right_join() election_data16 %&gt;% left_join(demographic_data) ## Joining, by = c(&quot;name&quot;, &quot;state&quot;) ## # A tibble: 3,141 × 17 ## name state votes_dem_2016 votes_gop_2016 total_votes_2016 per_dem_2016 ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Adams County IL 7633 22732 31770 0.240 ## 2 Alexander County IL 1262 1496 2820 0.448 ## 3 Bond County IL 2066 4884 7462 0.277 ## 4 Boone County IL 8952 12261 22604 0.396 ## 5 Brown County IL 475 1776 2336 0.203 ## 6 Bureau County IL 6010 9264 16303 0.369 ## 7 Calhoun County IL 739 1719 2556 0.289 ## 8 Carroll County IL 2437 4428 7354 0.331 ## 9 Cass County IL 1617 3216 5054 0.320 ## 10 Champaign County IL 49694 33235 89196 0.557 ## # … with 3,131 more rows, and 11 more variables: per_gop_2016 &lt;dbl&gt;, ## # diff_2016 &lt;dbl&gt;, winner &lt;chr&gt;, partywinner16 &lt;chr&gt;, pop &lt;dbl&gt;, ## # female &lt;dbl&gt;, white &lt;dbl&gt;, black &lt;dbl&gt;, travel_time &lt;dbl&gt;, land_area &lt;dbl&gt;, ## # hh_income &lt;dbl&gt; If the column that both data sets have in common has the same name, there’s no need to provide it. If this is not the case, you need to provide it in a character vector: election_data16 %&gt;% rename(county = name) %&gt;% right_join(demographic_data, by = c(&quot;county&quot; = &quot;name&quot;)) ## # A tibble: 10,348 × 18 ## county state.x votes_dem_2016 votes_gop_2016 total_votes_2016 per_dem_2016 ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Adams Co… IL 7633 22732 31770 0.240 ## 2 Adams Co… IL 7633 22732 31770 0.240 ## 3 Adams Co… IL 7633 22732 31770 0.240 ## 4 Adams Co… IL 7633 22732 31770 0.240 ## 5 Adams Co… IL 7633 22732 31770 0.240 ## 6 Adams Co… IL 7633 22732 31770 0.240 ## 7 Adams Co… IL 7633 22732 31770 0.240 ## 8 Adams Co… IL 7633 22732 31770 0.240 ## 9 Adams Co… IL 7633 22732 31770 0.240 ## 10 Alexande… IL 1262 1496 2820 0.448 ## # … with 10,338 more rows, and 12 more variables: per_gop_2016 &lt;dbl&gt;, ## # diff_2016 &lt;dbl&gt;, winner &lt;chr&gt;, partywinner16 &lt;chr&gt;, state.y &lt;chr&gt;, ## # pop &lt;dbl&gt;, female &lt;dbl&gt;, white &lt;dbl&gt;, black &lt;dbl&gt;, travel_time &lt;dbl&gt;, ## # land_area &lt;dbl&gt;, hh_income &lt;dbl&gt; Here, the problem is that the same counties exist in different states. Therefore, all combinations are returned. Hence, I need to specify two arguments: the county’s name and state. election_data16 %&gt;% rename(county = name) %&gt;% right_join(demographic_data, by = c(&quot;county&quot; = &quot;name&quot;, &quot;state&quot;)) ## # A tibble: 2,000 × 17 ## county state votes_dem_2016 votes_gop_2016 total_votes_2016 per_dem_2016 ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Adams County IL 7633 22732 31770 0.240 ## 2 Alexander County IL 1262 1496 2820 0.448 ## 3 Bond County IL 2066 4884 7462 0.277 ## 4 Boone County IL 8952 12261 22604 0.396 ## 5 Brown County IL 475 1776 2336 0.203 ## 6 Bureau County IL 6010 9264 16303 0.369 ## 7 Calhoun County IL 739 1719 2556 0.289 ## 8 Carroll County IL 2437 4428 7354 0.331 ## 9 Cass County IL 1617 3216 5054 0.320 ## 10 Champaign County IL 49694 33235 89196 0.557 ## # … with 1,990 more rows, and 11 more variables: per_gop_2016 &lt;dbl&gt;, ## # diff_2016 &lt;dbl&gt;, winner &lt;chr&gt;, partywinner16 &lt;chr&gt;, pop &lt;dbl&gt;, ## # female &lt;dbl&gt;, white &lt;dbl&gt;, black &lt;dbl&gt;, travel_time &lt;dbl&gt;, land_area &lt;dbl&gt;, ## # hh_income &lt;dbl&gt; Left joins return all rows which are in x. If a column is in x but not in y, an NA will be included at this position. Right joins work vice versa. 5.2.4 inner_join() election_data16 %&gt;% inner_join(demographic_data) ## Joining, by = c(&quot;name&quot;, &quot;state&quot;) ## # A tibble: 2,000 × 17 ## name state votes_dem_2016 votes_gop_2016 total_votes_2016 per_dem_2016 ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Adams County IL 7633 22732 31770 0.240 ## 2 Alexander County IL 1262 1496 2820 0.448 ## 3 Bond County IL 2066 4884 7462 0.277 ## 4 Boone County IL 8952 12261 22604 0.396 ## 5 Brown County IL 475 1776 2336 0.203 ## 6 Bureau County IL 6010 9264 16303 0.369 ## 7 Calhoun County IL 739 1719 2556 0.289 ## 8 Carroll County IL 2437 4428 7354 0.331 ## 9 Cass County IL 1617 3216 5054 0.320 ## 10 Champaign County IL 49694 33235 89196 0.557 ## # … with 1,990 more rows, and 11 more variables: per_gop_2016 &lt;dbl&gt;, ## # diff_2016 &lt;dbl&gt;, winner &lt;chr&gt;, partywinner16 &lt;chr&gt;, pop &lt;dbl&gt;, ## # female &lt;dbl&gt;, white &lt;dbl&gt;, black &lt;dbl&gt;, travel_time &lt;dbl&gt;, land_area &lt;dbl&gt;, ## # hh_income &lt;dbl&gt; An inner_join() returns all rows which are in x and y. 5.2.5 full_join() election_data16 %&gt;% full_join(demographic_data) ## Joining, by = c(&quot;name&quot;, &quot;state&quot;) ## # A tibble: 3,141 × 17 ## name state votes_dem_2016 votes_gop_2016 total_votes_2016 per_dem_2016 ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Adams County IL 7633 22732 31770 0.240 ## 2 Alexander County IL 1262 1496 2820 0.448 ## 3 Bond County IL 2066 4884 7462 0.277 ## 4 Boone County IL 8952 12261 22604 0.396 ## 5 Brown County IL 475 1776 2336 0.203 ## 6 Bureau County IL 6010 9264 16303 0.369 ## 7 Calhoun County IL 739 1719 2556 0.289 ## 8 Carroll County IL 2437 4428 7354 0.331 ## 9 Cass County IL 1617 3216 5054 0.320 ## 10 Champaign County IL 49694 33235 89196 0.557 ## # … with 3,131 more rows, and 11 more variables: per_gop_2016 &lt;dbl&gt;, ## # diff_2016 &lt;dbl&gt;, winner &lt;chr&gt;, partywinner16 &lt;chr&gt;, pop &lt;dbl&gt;, ## # female &lt;dbl&gt;, white &lt;dbl&gt;, black &lt;dbl&gt;, travel_time &lt;dbl&gt;, land_area &lt;dbl&gt;, ## # hh_income &lt;dbl&gt; A full_join() returns rows and columns from both x and y. 5.2.6 semi_join() Filtering joins only keep the cases from x, no data set is added. election_data16 %&gt;% semi_join(demographic_data) ## Joining, by = c(&quot;name&quot;, &quot;state&quot;) ## # A tibble: 2,000 × 10 ## name state votes_dem_2016 votes_gop_2016 total_votes_2016 per_dem_2016 ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Adams County IL 7633 22732 31770 0.240 ## 2 Alexander County IL 1262 1496 2820 0.448 ## 3 Bond County IL 2066 4884 7462 0.277 ## 4 Boone County IL 8952 12261 22604 0.396 ## 5 Brown County IL 475 1776 2336 0.203 ## 6 Bureau County IL 6010 9264 16303 0.369 ## 7 Calhoun County IL 739 1719 2556 0.289 ## 8 Carroll County IL 2437 4428 7354 0.331 ## 9 Cass County IL 1617 3216 5054 0.320 ## 10 Champaign County IL 49694 33235 89196 0.557 ## # … with 1,990 more rows, and 4 more variables: per_gop_2016 &lt;dbl&gt;, ## # diff_2016 &lt;dbl&gt;, winner &lt;chr&gt;, partywinner16 &lt;chr&gt; The semi_join() returns all rows from x with matching values in y. You can compare it to a right_join() but without adding the columns of y. 5.2.7 anti_join() election_data16 %&gt;% anti_join(demographic_data) ## Joining, by = c(&quot;name&quot;, &quot;state&quot;) ## # A tibble: 1,141 × 10 ## name state votes_dem_2016 votes_gop_2016 total_votes_2016 per_dem_2016 ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Onslow County NC 17156 36342 55364 0.310 ## 2 Orange County NC 59105 18373 79830 0.740 ## 3 Pamlico County NC 2427 4225 6772 0.358 ## 4 Pasquotank County NC 8455 8082 16964 0.498 ## 5 Pender County NC 9086 17317 27072 0.336 ## 6 Perquimans County NC 2291 4143 6595 0.347 ## 7 Person County NC 7772 11116 19303 0.403 ## 8 Pitt County NC 40967 35191 78264 0.523 ## 9 Polk County NC 3715 6738 10723 0.346 ## 10 Randolph County NC 13074 49156 63615 0.206 ## # … with 1,131 more rows, and 4 more variables: per_gop_2016 &lt;dbl&gt;, ## # diff_2016 &lt;dbl&gt;, winner &lt;chr&gt;, partywinner16 &lt;chr&gt; anti_join() returns all rows from x with no matching rows in y. 5.2.8 bind_rows() and bind_cols() Binding tibbles together is made easy using the bind_*() functions. bind_rows() binds them together by rows, bind_cols() by columns. For the former, it is important that column names are matching. Otherwise, the non-matching ones will be added as separate columns and NAs introduced. IDs can be added by using the .id = argument, where the name of the id column can be specified. election_data16 %&gt;% semi_join(demographic_data) %&gt;% bind_rows(election_data16 %&gt;% anti_join(demographic_data), .id = &quot;id&quot;) ## Joining, by = c(&quot;name&quot;, &quot;state&quot;) ## Joining, by = c(&quot;name&quot;, &quot;state&quot;) ## # A tibble: 3,141 × 11 ## id name state votes_dem_2016 votes_gop_2016 total_votes_2016 per_dem_2016 ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 Adam… IL 7633 22732 31770 0.240 ## 2 1 Alex… IL 1262 1496 2820 0.448 ## 3 1 Bond… IL 2066 4884 7462 0.277 ## 4 1 Boon… IL 8952 12261 22604 0.396 ## 5 1 Brow… IL 475 1776 2336 0.203 ## 6 1 Bure… IL 6010 9264 16303 0.369 ## 7 1 Calh… IL 739 1719 2556 0.289 ## 8 1 Carr… IL 2437 4428 7354 0.331 ## 9 1 Cass… IL 1617 3216 5054 0.320 ## 10 1 Cham… IL 49694 33235 89196 0.557 ## # … with 3,131 more rows, and 4 more variables: per_gop_2016 &lt;dbl&gt;, ## # diff_2016 &lt;dbl&gt;, winner &lt;chr&gt;, partywinner16 &lt;chr&gt; For bind_cols(), the length has to be the same. Duplicated column names will be changed. election_data12 %&gt;% bind_cols(election_data16) ## New names: ## * name -&gt; name...1 ## * state -&gt; state...2 ## * winner -&gt; winner...6 ## * partywinner16 -&gt; partywinner16...7 ## * name -&gt; name...10 ## * ... ## # A tibble: 3,141 × 19 ## name...1 state...2 per_dem_2012 per_gop_2012 diff_2012 winner...6 ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 Adams County IL 0.315 0.667 10744 Trump ## 2 Alexander County IL 0.561 0.425 476 Trump ## 3 Bond County IL 0.412 0.559 1075 Trump ## 4 Boone County IL 0.463 0.520 1216 Trump ## 5 Brown County IL 0.333 0.640 724 Trump ## 6 Bureau County IL 0.489 0.491 33 Trump ## 7 Calhoun County IL 0.419 0.559 360 Trump ## 8 Carroll County IL 0.496 0.482 107 Trump ## 9 Cass County IL 0.422 0.557 657 Trump ## 10 Champaign County IL 0.520 0.452 5292 Clinton ## # … with 3,131 more rows, and 13 more variables: partywinner16...7 &lt;chr&gt;, ## # winner12 &lt;chr&gt;, partywinner12 &lt;chr&gt;, name...10 &lt;chr&gt;, state...11 &lt;chr&gt;, ## # votes_dem_2016 &lt;dbl&gt;, votes_gop_2016 &lt;dbl&gt;, total_votes_2016 &lt;dbl&gt;, ## # per_dem_2016 &lt;dbl&gt;, per_gop_2016 &lt;dbl&gt;, diff_2016 &lt;dbl&gt;, winner...18 &lt;chr&gt;, ## # partywinner16...19 &lt;chr&gt; 5.3 Further links Chapter in R4DS More on window functions in the vignette: vignette(\"window-functions\") Again, the cheatsheet A tutorial on YouTube Another introduction can be found here. The chapter in R4DS has some nice diagrams. References "],["stringregex.html", "Chapter 6 String manipulation with stringr and regular expressions 6.1 Basic manipulations 6.2 Regular expressions 6.3 More advanced string manipulation 6.4 Further links", " Chapter 6 String manipulation with stringr and regular expressions When analyzing data, a significant number of variables will be in some sort of text format. When you want to manipulate those variables, an easy approach would be exporting the data to MS Excel and then just perform those manipulations by hand. This is very time-consuming, though, and, hence, I rather recommend the R way, which scales well and works fast for data sets of varying sizes. Quick reminder: a string is an element of a character vector and can be created by simply wrapping some text in back ticks: string &lt;- &quot;Hi, how are you doing?&quot; vector_of_strings &lt;- c(&quot;Hi, how are you doing?&quot;, &quot;I&#39;m doing well, HBY?&quot;, &quot;Me too, thanks for asking.&quot;) The stringr package contains a multitude of commands (49 in total) which can be used to achieve a couple of things: manipulating character vectors; operations which are sensitive to different locales; matching patterns. Basically, those goals can also be achieved with base R functions, but stringr’s advantage is its consistency. The makers of stringr describe it as A consistent, simple and easy to use set of wrappers around the fantastic ‘stringi’ package. All function and argument names (and positions) are consistent, all functions deal with “NA”’s and zero length vectors in the same way, and the output from one function is easy to feed into the input of another. Every stringr function starts with str_ – which facilitates finding the proper command: just type str_ and RStudio’s auto-suggest function should take care of the rest (if it doesn’t pop up by itself, you can trigger it by hitting the tab-key). Also, they take a vector of strings as their first argument, which facilitates using them in a %&gt;%-pipeline and adding them to a mutate()-call. One important component of stringr functions is regular expressions which will be introduced later as well. 6.1 Basic manipulations In the following, I will introduce you to a number of different operations that can be performed on strings. 6.1.1 Changing the case of the words A basic operation is changing words’ case. str_to_lower(vector_of_strings) ## [1] &quot;hi, how are you doing?&quot; &quot;i&#39;m doing well, hby?&quot; ## [3] &quot;me too, thanks for asking.&quot; str_to_upper(vector_of_strings) ## [1] &quot;HI, HOW ARE YOU DOING?&quot; &quot;I&#39;M DOING WELL, HBY?&quot; ## [3] &quot;ME TOO, THANKS FOR ASKING.&quot; str_to_title(vector_of_strings) ## [1] &quot;Hi, How Are You Doing?&quot; &quot;I&#39;m Doing Well, Hby?&quot; ## [3] &quot;Me Too, Thanks For Asking.&quot; str_to_sentence(vector_of_strings) ## [1] &quot;Hi, how are you doing?&quot; &quot;I&#39;m doing well, hby?&quot; ## [3] &quot;Me too, thanks for asking.&quot; 6.1.2 Determining a string’s length Determining the string’s number of characters goes as follows: str_length(vector_of_strings) ## [1] 22 20 26 6.1.3 Extracting particular characters Characters can be extracted (by position) using str_sub str_sub(vector_of_strings, start = 1, end = 5) # extracting first to fifth character ## [1] &quot;Hi, h&quot; &quot;I&#39;m d&quot; &quot;Me to&quot; str_sub(vector_of_strings, start = -5, end = -1) # extracting fifth-to-last to last character ## [1] &quot;oing?&quot; &quot; HBY?&quot; &quot;king.&quot; You can also use str_sub() to replace strings. E.g., to replace the last character by a full stop, you can do the following: str_sub(vector_of_strings, start = -1) &lt;- &quot;.&quot; vector_of_strings ## [1] &quot;Hi, how are you doing.&quot; &quot;I&#39;m doing well, HBY.&quot; ## [3] &quot;Me too, thanks for asking.&quot; However, in everyday use you would probably go with str_replace() and regular expressions. 6.1.4 Concatenating strings Similar to how c() puts together different elements (or vectors of length 1) into a single vector, str_c() can be used to concatenate several strings into a single string. This can, for instance, be used to write some birthday invitations. names &lt;- c(&quot;Inger&quot;, &quot;Peter&quot;, &quot;Kalle&quot;, &quot;Ingrid&quot;) str_c(&quot;Hi&quot;, names, &quot;I hope you&#39;re doing well. As per this letter, I invite you to my birthday party.&quot;) ## [1] &quot;HiIngerI hope you&#39;re doing well. As per this letter, I invite you to my birthday party.&quot; ## [2] &quot;HiPeterI hope you&#39;re doing well. As per this letter, I invite you to my birthday party.&quot; ## [3] &quot;HiKalleI hope you&#39;re doing well. As per this letter, I invite you to my birthday party.&quot; ## [4] &quot;HiIngridI hope you&#39;re doing well. As per this letter, I invite you to my birthday party.&quot; Well, this looks kind of ugly, as there are no spaces and commas are lacking as well. You can fix that by determining a separator using the sep argument. str_c(&quot;Hi&quot;, names, &quot;I hope you&#39;re doing well. As per this letter, I invite you to my birthday party.&quot;, sep = &quot;, &quot;) ## [1] &quot;Hi, Inger, I hope you&#39;re doing well. As per this letter, I invite you to my birthday party.&quot; ## [2] &quot;Hi, Peter, I hope you&#39;re doing well. As per this letter, I invite you to my birthday party.&quot; ## [3] &quot;Hi, Kalle, I hope you&#39;re doing well. As per this letter, I invite you to my birthday party.&quot; ## [4] &quot;Hi, Ingrid, I hope you&#39;re doing well. As per this letter, I invite you to my birthday party.&quot; You could also collapse the strings contained in a vector together into one single string using the collapse argument. str_c(names, collapse = &quot;, &quot;) ## [1] &quot;Inger, Peter, Kalle, Ingrid&quot; This can also be achieved using the str_flatten() function. str_flatten(names, collapse = &quot;, &quot;) ## [1] &quot;Inger, Peter, Kalle, Ingrid&quot; 6.1.5 Repetition Repeating (or duplicating) strings is performed using str_dup(). The function takes two arguments: the string to be duplicated and the number of times. str_dup(&quot;felix&quot;, 2) ## [1] &quot;felixfelix&quot; str_dup(&quot;felix&quot;, 1:3) ## [1] &quot;felix&quot; &quot;felixfelix&quot; &quot;felixfelixfelix&quot; str_dup(names, 2) ## [1] &quot;IngerInger&quot; &quot;PeterPeter&quot; &quot;KalleKalle&quot; &quot;IngridIngrid&quot; str_dup(names, 1:4) ## [1] &quot;Inger&quot; &quot;PeterPeter&quot; ## [3] &quot;KalleKalleKalle&quot; &quot;IngridIngridIngridIngrid&quot; 6.1.6 Removing unnecessary whitespaces Often text contains unnecessary whitespaces. unnecessary_whitespaces &lt;- c(&quot; on the left&quot;, &quot;on the right &quot;, &quot; on both sides &quot;, &quot; literally everywhere &quot;) Removing the ones at the beginning or the end of a string can be accomplished using str_trim(). str_trim(unnecessary_whitespaces, side = &quot;left&quot;) ## [1] &quot;on the left&quot; &quot;on the right &quot; ## [3] &quot;on both sides &quot; &quot;literally everywhere &quot; str_trim(unnecessary_whitespaces, side = &quot;right&quot;) ## [1] &quot; on the left&quot; &quot;on the right&quot; ## [3] &quot; on both sides&quot; &quot; literally everywhere&quot; str_trim(unnecessary_whitespaces, side = &quot;both&quot;) # the default option ## [1] &quot;on the left&quot; &quot;on the right&quot; ## [3] &quot;on both sides&quot; &quot;literally everywhere&quot; str_trim() could not fix the last string though, where unnecessary whitespaces were also present in between words. Here, str_squish is more appropriate. It removes leading or trailing whitespaces as well as duplicated ones in between words. str_squish(unnecessary_whitespaces) ## [1] &quot;on the left&quot; &quot;on the right&quot; &quot;on both sides&quot; ## [4] &quot;literally everywhere&quot; 6.2 Regular expressions Up to now, you have been introduced to the more basic functions of the stringr package. Those are useful, for sure, yet limited. However, to make use of the full potential of stringr, you will first have to get acquainted to regular expressions (also often abbreviated as “regex” with plural “regexes”). Those regular expressions are patterns that can be used to describe certain strings. Hence, if you want to replace certain words with another one, you can write the proper regex and it will identify the strings you want to replace and the stringr function (i.e., str_replace()) will take care of the rest. Exemplary use cases of regexes are the identification of phone numbers, email addresses, or whether a password you choose on a web page consists of enough characters, an upper-case character, and at least one special character. Before you dive into regexes, beware that they are quite complicated in the beginning (honestly, I was quite overwhelmed when I encountered them first). Yet, mastering them is very rewarding and will definitely pay off in the future. 6.2.1 Literal characters The most basic regex patterns consist of literal characters only. str_view() tells you which parts of a string match a pattern is present in the element. five_largest_cities &lt;- c(&quot;Stockholm&quot;, &quot;Göteborg&quot;, &quot;Malmö&quot;, &quot;Uppsala&quot;, &quot;Västerås&quot;) Note that regexes are case-sensitive. str_view(five_largest_cities, &quot;stockholm&quot;) str_view(five_largest_cities, &quot;Stockholm&quot;) They also match parts of words: str_view(five_largest_cities, &quot;borg&quot;) Moreover, they are “greedy,” they only match the first occurrence (in “Stockholm”): str_view(five_largest_cities, &quot;o&quot;) This can be addressed in the stringr package by using str_._all() function – but more on that later. If you want to match multiple literal characters (or words, for that sake), you can connect them using the | meta character (more on meta characters later). str_view(five_largest_cities, &quot;Stockholm|Göteborg&quot;) question: automate the pattern-generating process using str_c – hint: collapse = “|” Every letter of the English alphabet (or number/or combination of those) can serve as a literal character. Those literal characters match themselves. This is, however, not the case with the other sort of characters, so-called meta characters. 6.2.2 Metacharacters When using regexes, the following characters are considered meta characters and have a special meaning: . \\ | ( ) { } [ ] ^ $ - * + ? 6.2.2.1 The wildcard Did you notice how I used the dot to refer to the entirety of the str_._all() functions? This is basically what the . meta-character does: it matches every character except for a new line. The first call extracts all function names from the stringr package, the second one shows the matches (i.e., the elements of the vector where it can find the pattern). stringr_functions &lt;- ls(&quot;package:stringr&quot;) str_detect(stringr_functions, &quot;str_._all&quot;) ## [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE ## [13] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE ## [25] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE ## [37] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE ## [49] FALSE FALSE FALSE FALSE Well, as you can see, there are none. This is due to the fact that the . can only replace one character. We need some sort of multiplier to find them. The ones available are: ? – zero or one * – zero or more + – one or more {n} – exactly n {n,} – n or more {n,m} – between n and m In our case, the appropriate one is +: str_detect(stringr_functions, &quot;str_.+_all&quot;) ## [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE ## [13] FALSE FALSE FALSE TRUE FALSE FALSE FALSE FALSE FALSE FALSE TRUE FALSE ## [25] TRUE FALSE FALSE FALSE TRUE FALSE TRUE FALSE FALSE FALSE FALSE FALSE ## [37] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE TRUE ## [49] FALSE FALSE FALSE FALSE However, if you want to match the character dot? This problem may arise when searching for clock time. A naive regex might look like this: vectors_with_time &lt;- c(&quot;13500&quot;, &quot;13M00&quot;, &quot;13.00&quot;) str_detect(vectors_with_time, &quot;13.00&quot;) ## [1] TRUE TRUE TRUE Yet, it matches everything. We need some sort of literal dot. Here, the meta character \\ comes in handy. By putting it in front of the meta character, it does no longer has its special meaning, and is interpreted as a literal character. This procedure is referred to as “escaping.” Hence, \\ is also referred to as the “escape character.” Note that you will need to escape \\ as well, and therefore it will look like this: \\\\.. str_detect(vectors_with_time, &quot;13\\\\.00&quot;) ## [1] FALSE FALSE TRUE 6.2.2.2 Sets of characters You can also define sets of multiple characters using the [ ] meta characters. This can be used to define multiple possible characters that can appear in the same place. sp_ce &lt;- c(&quot;spice&quot;, &quot;space&quot;) str_view(sp_ce, &quot;sp[ai]ce&quot;) You can also define certain ranges of characters using the - meta character: Same holds for numbers: american_phone_number &lt;- &quot;(555) 555-1234&quot; str_view(american_phone_number, &quot;\\\\([0-9]{3}\\\\) [0-9]{3}-[0-9]{4}&quot;) There are also predefined sets of characters, for instance digits or letters, which are called character classes. You can find them on the stringr cheatsheet. Furthermore, you can put almost every meta character inside the square brackets without escaping them. This does not apply to the the caret (^) in first position, the dash -, the closing square bracket ], and the backslash \\. str_view(vector_of_strings, &quot;[.]&quot;) 6.2.2.3 Negating sets of characters Sometimes you will also want to exclude certain sets of characters or words. In order to achieve this, you can use the ^ meta character at the beginning of the range or set you are defining. str_view(sp_ce, &quot;sp[^i]ce&quot;) 6.2.2.4 Anchors There is also a way to define whether you want the pattern to be present in the beginning ^ or at the end $ of a string. sentences are a couple of (i.e., 720) predefined example sentences. If I were now interested in the number of sentences that begin with a “the,” I could write the following regex: shortened_sentences &lt;- sentences[1:10] str_view(shortened_sentences, &quot;^The&quot;) If I wanted to know how many start with a “The” and end with a full stop, I could do this one: str_view(shortened_sentences, &quot;^The.+\\\\.$&quot;) 6.2.2.5 Boundaries Note that right now, the regex also matches the sentence which starts with a “These.” In order to address this, I need to tell the machine that it should only accept a “The” if there starts a new word thereafter. In regex syntax, this is done using so-called boundaries. Those are defined as \\b as a word boundary and \\B as no word boundary. (Note that you will need an additional escape character as you will have to escape the escape character itself.) In my example, I would include the former if I were to search for sentences that begin with a single “The” and the latter if I were to search for sentences that begin with a word that starts with a “The” but are not “The” – such as “These.” str_view(shortened_sentences, &quot;^The\\\\b.+\\\\.$&quot;) str_view(shortened_sentences, &quot;^The\\\\B.+\\\\.$&quot;) 6.2.2.6 Lookarounds A final common task is to extract certain words or values based on what comes before or after them. Look at the following example: heights &lt;- c(&quot;1m30cm&quot;, &quot;2m01cm&quot;, &quot;3m10cm&quot;) Here, in order to identify the height in meters, the first task is to identify all the numbers that are followed by an “m.” The regex syntax for this looks like this: A(?=pattern) with A being the entity that is supposed to be found (hence, in this case, [0-9]+). str_view(heights, &quot;[0-9]+(?=m)&quot;) The second step now is to identify the centimeters. This could of course be achieved using the same regex and replacing m by cm. However, we can also harness a so-called negative look ahead A(?!pattern), a so-called look behind (?&lt;=pattern)A. The negative counterpart, the negative look behind (?&lt;!pattern)A could be used to extract the meters. The negative look ahead basically returns everything that is not followed by the defined pattern. The look behind returns everything that is preceded by the pattern, the negative look behind returns everything that is not preceded by the pattern. In the following, I demonstrate how you could extract the centimeters using negative look ahead and look behind. str_view(heights, &quot;[0-9]+(?!m)&quot;) # negative look ahead str_view(heights, &quot;(?&lt;=m)[0-9]+&quot;) # look behind 6.3 More advanced string manipulation Yow that you have learned about regexes, you can unleash the full power of stringr. The basic syntax of a stringr function looks as follows: str_*(string, regex(\"\")). Some stringr functions also have the suffix _all which implies that they perform the operation not only on the first match (“greedy”) but on every match. In order to demonstrate the different functions, I will again rely on the subset of example sentences. 6.3.1 Detect matches str_detect can be used whether a certain pattern is present in the string. str_detect(shortened_sentences, &quot;The\\\\b&quot;) ## [1] TRUE FALSE FALSE FALSE FALSE TRUE TRUE TRUE FALSE FALSE This also works very well in a dplyr::filter() call. Finding all action movies in the IMDB data set can be solved like this: imdb_raw %&gt;% filter(str_detect(Genre, &quot;Action&quot;)) ## # A tibble: 303 × 12 ## Rank Title Genre Description Director Actors Year `Runtime (Minut… Rating ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 Guard… Actio… A group of… James G… Chris… 2014 121 8.1 ## 2 5 Suici… Actio… A secret g… David A… Will … 2016 123 6.2 ## 3 6 The G… Actio… European m… Yimou Z… Matt … 2016 103 6.1 ## 4 9 The L… Actio… A true-lif… James G… Charl… 2016 141 7.1 ## 5 13 Rogue… Actio… The Rebel … Gareth … Felic… 2016 133 7.9 ## 6 15 Colos… Actio… Gloria is … Nacho V… Anne … 2016 109 6.4 ## 7 18 Jason… Actio… The CIA&#39;s … Paul Gr… Matt … 2016 123 6.7 ## 8 25 Indep… Actio… Two decade… Roland … Liam … 2016 120 5.3 ## 9 27 Bahub… Actio… In ancient… S.S. Ra… Prabh… 2015 159 8.3 ## 10 30 Assas… Actio… When Callu… Justin … Micha… 2016 115 5.9 ## # … with 293 more rows, and 3 more variables: Votes &lt;dbl&gt;, ## # Revenue (Millions) &lt;dbl&gt;, Metascore &lt;dbl&gt; If you want to know whether there are multiple matches present in each string, you can use str_count. Here, it might by advisable to set the ignore_case option to TRUE: str_count(shortened_sentences, regex(&quot;The\\\\b&quot;, ignore_case = TRUE)) ## [1] 2 2 1 0 0 1 2 1 0 0 If you want to locate the match in the string, use str_locate. This returns a matrix, which is basically a vector of multiple dimensions. str_locate(shortened_sentences, regex(&quot;The\\\\b&quot;, ignore_case = TRUE)) ## start end ## [1,] 1 3 ## [2,] 6 8 ## [3,] 19 21 ## [4,] NA NA ## [5,] NA NA ## [6,] 1 3 ## [7,] 1 3 ## [8,] 1 3 ## [9,] NA NA ## [10,] NA NA Moreover, this is a good example for the greediness of stringr functions. Hence, it is advisable to use str_locate_all which returns a list with one matrix for each element of the original vector: str_locate_all(shortened_sentences, regex(&quot;The\\\\b&quot;, ignore_case = TRUE)) ## [[1]] ## start end ## [1,] 1 3 ## [2,] 25 27 ## ## [[2]] ## start end ## [1,] 6 8 ## [2,] 19 21 ## ## [[3]] ## start end ## [1,] 19 21 ## ## [[4]] ## start end ## ## [[5]] ## start end ## ## [[6]] ## start end ## [1,] 1 3 ## ## [[7]] ## start end ## [1,] 1 3 ## [2,] 27 29 ## ## [[8]] ## start end ## [1,] 1 3 ## ## [[9]] ## start end ## ## [[10]] ## start end 6.3.2 Mutating strings Mutating strings usually implies the replacement of certain elements (e.g., words) with other elements (or removing them, which is basically a special case of replacing them). In stringr this is performed using str_replace(string, pattern, replacement) and str_replace_all(string, pattern, replacement). If I wanted, for instance, replace all “m” letters by “meters,” I would go about this the following way: str_replace(heights, &quot;m&quot;, &quot;meters&quot;) ## [1] &quot;1meters30cm&quot; &quot;2meters01cm&quot; &quot;3meters10cm&quot; Note that str_replace_all would have lead to the following outcome: str_replace_all(heights, &quot;m&quot;, &quot;meters&quot;) ## [1] &quot;1meters30cmeters&quot; &quot;2meters01cmeters&quot; &quot;3meters10cmeters&quot; However, I also want to replace the “cm” with “centimeters,” hence, I can harness another feature of str_replace_all(): str_replace_all(heights, c(&quot;m&quot; = &quot;meters&quot;, &quot;cm&quot; = &quot;centimeters&quot;)) ## [1] &quot;1meters30centimeterseters&quot; &quot;2meters01centimeterseters&quot; ## [3] &quot;3meters10centimeterseters&quot; What becomes obvious is that a “simple” regex containing just literal characters more often than not does not suffice. It will be your task to fix this. And while on it, you can also address the meter/meters problem – a “1” needs meter instead of meters. Another feature is that the replacements are performed in order. You can harness this for solving the problem. Solution. Click to expand! Solution: str_replace_all(heights, c(&quot;(?&lt;=[2-9]{1})m&quot; = &quot;meters&quot;, &quot;(?&lt;=[0-9]{2})m&quot; = &quot;meters&quot;, &quot;(?&lt;=1)m&quot; = &quot;meter&quot;, &quot;(?&lt;=01)cm$&quot; = &quot;centimeter&quot;, &quot;cm$&quot; = &quot;centimeters&quot;)) ## [1] &quot;1meter30centimeters&quot; &quot;2meters01centimeter&quot; &quot;3meters10centimeters&quot; 6.3.3 Extracting text str_extract(_all)() can be used to extract matching strings. In the mtcars data set, the first word describes the car brand. Here, I harness another regexp, the \\\\w which stands for any word character. Its opponent is \\\\W for any non-word character. mtcars %&gt;% rownames_to_column(var = &quot;car_model&quot;) %&gt;% transmute(manufacturer = str_extract(car_model, &quot;^\\\\w+\\\\b&quot;)) ## manufacturer ## 1 Mazda ## 2 Mazda ## 3 Datsun ## 4 Hornet ## 5 Hornet ## 6 Valiant ## 7 Duster ## 8 Merc ## 9 Merc ## 10 Merc ## 11 Merc ## 12 Merc ## 13 Merc ## 14 Merc ## 15 Cadillac ## 16 Lincoln ## 17 Chrysler ## 18 Fiat ## 19 Honda ## 20 Toyota ## 21 Toyota ## 22 Dodge ## 23 AMC ## 24 Camaro ## 25 Pontiac ## 26 Fiat ## 27 Porsche ## 28 Lotus ## 29 Ford ## 30 Ferrari ## 31 Maserati ## 32 Volvo 6.3.4 Split vectors Another use case here would have been to split it into two columns: manufacturer and model. One approach would be to use str_split(). This function splits the string at every occurrence of the predefined patter. In this example, I use a word boundary as the pattern: manufacturer_model &lt;- rownames(mtcars) str_split(manufacturer_model, &quot;\\\\b&quot;) %&gt;% head() ## [[1]] ## [1] &quot;&quot; &quot;Mazda&quot; &quot; &quot; &quot;RX4&quot; &quot;&quot; ## ## [[2]] ## [1] &quot;&quot; &quot;Mazda&quot; &quot; &quot; &quot;RX4&quot; &quot; &quot; &quot;Wag&quot; &quot;&quot; ## ## [[3]] ## [1] &quot;&quot; &quot;Datsun&quot; &quot; &quot; &quot;710&quot; &quot;&quot; ## ## [[4]] ## [1] &quot;&quot; &quot;Hornet&quot; &quot; &quot; &quot;4&quot; &quot; &quot; &quot;Drive&quot; &quot;&quot; ## ## [[5]] ## [1] &quot;&quot; &quot;Hornet&quot; &quot; &quot; &quot;Sportabout&quot; &quot;&quot; ## ## [[6]] ## [1] &quot;&quot; &quot;Valiant&quot; &quot;&quot; This outputs a list containing the different singular words/special characters. This doesn’t make sense in this case. Here, however, the structure of the string is always roughly the same: “\\[manufacturer\\]\\[ \\]\\[model description\\].” Moreover, the manufacturer is only one word. Hence, the task can be fixed by splitting the string after the first word, which should indicate the manufacturer. This can be accomplished using str_split_fixed(). Fixed means that the number of splits is predefined. This returns a metric that can easily become a tibble. str_split_fixed(manufacturer_model, &quot;(?&lt;=\\\\w)\\\\b&quot;, n = 2) %&gt;% as_tibble() %&gt;% rename(manufacturer = V1, model = V2) ## Warning: The `x` argument of `as_tibble.matrix()` must have unique column names if `.name_repair` is omitted as of tibble 2.0.0. ## Using compatibility `.name_repair`. ## # A tibble: 32 × 2 ## manufacturer model ## &lt;chr&gt; &lt;chr&gt; ## 1 Mazda &quot; RX4&quot; ## 2 Mazda &quot; RX4 Wag&quot; ## 3 Datsun &quot; 710&quot; ## 4 Hornet &quot; 4 Drive&quot; ## 5 Hornet &quot; Sportabout&quot; ## 6 Valiant &quot;&quot; ## 7 Duster &quot; 360&quot; ## 8 Merc &quot; 240D&quot; ## 9 Merc &quot; 230&quot; ## 10 Merc &quot; 280&quot; ## # … with 22 more rows 6.4 Further links The stringr cheatsheet. A YouTube video on regexes by Johns Hopkins professor Roger Peng. And a chapter by Roger Peng. A website for practicing regexes. "],["workwithfactors.html", "Chapter 7 Factors with forcats 7.1 Creating a factor 7.2 Some basic operations 7.3 Further links", " Chapter 7 Factors with forcats A common example for textual data is categorical data. An example for this would be the survey question about a person’s marital status (which might take “married,” “widowed,” “separated,” “divorced,” “single”), hence a variable which can take a limited number of values. In R, so-called factors are used to represent categorical data. In the following, I will briefly introduce you to the forcats package (nice anagram, Hadley!). Factors are augmented vectors which build upon integers. If you want to learn more about them, consider reading this paper. 7.1 Creating a factor You can create a factor in two manners. Take a character vector and coerce it to a factor parties &lt;- c(&quot;AfD&quot;, &quot;CDU&quot;, &quot;CSU&quot;, &quot;FDP&quot;, &quot;Greens&quot;, &quot;Leftists&quot;, &quot;SPD&quot;) parties_fct &lt;- as_factor(parties) typeof(parties_fct) ## [1] &quot;integer&quot; Create it from scratch by providing levels and a vector respectively party_sample &lt;- c(sample(parties, 49, replace = TRUE), &quot;CUD&quot;) factor(party_sample, levels = parties) ## [1] FDP Leftists Leftists AfD CDU CSU Greens CSU ## [9] CSU AfD FDP AfD AfD Greens CSU CDU ## [17] SPD CDU AfD Leftists CSU FDP Leftists AfD ## [25] CSU SPD Greens FDP SPD CDU Greens SPD ## [33] AfD AfD CDU SPD CSU FDP Greens SPD ## [41] Greens CSU Leftists AfD CDU Greens Greens FDP ## [49] SPD &lt;NA&gt; ## Levels: AfD CDU CSU FDP Greens Leftists SPD If you want to access the levels, use levels() levels(parties_fct) ## [1] &quot;AfD&quot; &quot;CDU&quot; &quot;CSU&quot; &quot;FDP&quot; &quot;Greens&quot; &quot;Leftists&quot; &quot;SPD&quot; 7.2 Some basic operations I will have a further look into factors using data on the presidential elections in the U.S. election_data &lt;- read_csv(&quot;data/pres16results.csv&quot;) %&gt;% drop_na() %&gt;% glimpse() ## Rows: 18475 Columns: 9 ## ── Column specification ──────────────────────────────────────────────────────── ## Delimiter: &quot;,&quot; ## chr (5): county, fips, cand, st, lead ## dbl (4): pct_report, votes, total_votes, pct ## ## ℹ Use `spec()` to retrieve the full column specification for this data. ## ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message. ## Rows: 18,007 ## Columns: 9 ## $ county &lt;chr&gt; &quot;Los Angeles County&quot;, &quot;Los Angeles County&quot;, &quot;Los Angeles C… ## $ fips &lt;chr&gt; &quot;6037&quot;, &quot;6037&quot;, &quot;6037&quot;, &quot;6037&quot;, &quot;6037&quot;, &quot;17031&quot;, &quot;17031&quot;, … ## $ cand &lt;chr&gt; &quot;Hillary Clinton&quot;, &quot;Donald Trump&quot;, &quot;Gary Johnson&quot;, &quot;Jill S… ## $ st &lt;chr&gt; &quot;CA&quot;, &quot;CA&quot;, &quot;CA&quot;, &quot;CA&quot;, &quot;CA&quot;, &quot;IL&quot;, &quot;IL&quot;, &quot;IL&quot;, &quot;IL&quot;, &quot;TX&quot;… ## $ pct_report &lt;dbl&gt; 1.0000, 1.0000, 1.0000, 1.0000, 1.0000, 0.9746, 0.9746, 0.… ## $ votes &lt;dbl&gt; 1654626, 542591, 56905, 46682, 13471, 1528582, 440213, 559… ## $ total_votes &lt;dbl&gt; 2314275, 2314275, 2314275, 2314275, 2314275, 2055215, 2055… ## $ pct &lt;dbl&gt; 0.714965162, 0.234453987, 0.024588694, 0.020171328, 0.0058… ## $ lead &lt;chr&gt; &quot;Hillary Clinton&quot;, &quot;Hillary Clinton&quot;, &quot;Hillary Clinton&quot;, &quot;… Which variables should be converted to factors? – county, cand, st, lead. election_data_w_fct &lt;- election_data %&gt;% mutate(county = as_factor(county), candidate = as_factor(cand), state = as_factor(st), lead = as_factor(lead)) %&gt;% select(county, candidate, state, pct_report:pct, lead) 7.2.1 Reordering factors Sometimes you want to reorder factors – for instance, when you want to create plots. (Note: you will learn more on plots in the next session on data visualization) election_data_w_fct %&gt;% group_by(state) %&gt;% summarize(sum_votes = sum(votes)) %&gt;% ggplot(aes(x = sum_votes, y = state)) + geom_point() Two orders would make sense: alphabetical and according to their number of votes. fct_reorder() takes another variable and orders the factor according to it. election_data_w_fct %&gt;% group_by(state) %&gt;% summarize(sum_votes = sum(votes)) %&gt;% mutate(state = fct_reorder(state, sum_votes)) %&gt;% ggplot(aes(x = sum_votes, y = state)) + geom_point() If you want to have it ordered the other way round, multiply the ordering variable with -1: election_data_w_fct %&gt;% group_by(state) %&gt;% summarize(sum_votes = sum(votes)) %&gt;% mutate(state = fct_reorder(state, sum_votes*(-1))) %&gt;% ggplot(aes(x = sum_votes, y = state)) + geom_point() You could also achieve this by calling fct_rev() afterwards: it reverses the order of the factor. election_data_w_fct %&gt;% group_by(state) %&gt;% summarize(sum_votes = sum(votes)) %&gt;% mutate(state = fct_reorder(state, sum_votes), state = fct_rev(state)) %&gt;% ggplot(aes(x = sum_votes, y = state)) + geom_point() If you want to do bar plots, which you can use to depict the frequency of a value, you can order them according to the frequency they appear in using fct_infreq(): election_data_w_fct %&gt;% mutate(lead = lead %&gt;% fct_infreq() %&gt;% fct_rev()) %&gt;% ggplot(aes(x = lead)) + geom_bar() 7.2.2 Modifying levels Remember the first factor? You need to put some graphs together and decide that you would rather like to use the original German names for the parties. Go for fct_recode(). parties_fct_ger &lt;- fct_recode(parties_fct, &quot;Buendnis90/Die Gruenen&quot; = &quot;Greens&quot;, &quot;Die Linke&quot; = &quot;Leftists&quot; ) Damn, now the levels are not in alphabetical order anymore. levels(parties_fct_ger) ## [1] &quot;AfD&quot; &quot;CDU&quot; &quot;CSU&quot; ## [4] &quot;FDP&quot; &quot;Buendnis90/Die Gruenen&quot; &quot;Die Linke&quot; ## [7] &quot;SPD&quot; In this case, this can be done pretty quickly. Just copy the levels and manipulate the order: parties_fct_ger_alphabetical &lt;- fct_relevel(parties_fct_ger, c(&quot;AfD&quot;, &quot;Buendnis90/Die Gruenen&quot;, &quot;CDU&quot;, &quot;CSU&quot;, &quot;Die Linke&quot;, &quot;FDP&quot;, &quot;SPD&quot;)) levels(parties_fct_ger_alphabetical) ## [1] &quot;AfD&quot; &quot;Buendnis90/Die Gruenen&quot; &quot;CDU&quot; ## [4] &quot;CSU&quot; &quot;Die Linke&quot; &quot;FDP&quot; ## [7] &quot;SPD&quot; Now you need to write something for someone who is not particular familiar with the political landscape in Germany and rather wants “left,” “center,” and “right” instead of the party’s names. Give fct_collapse() a shot – and feel free to change it if you disagree with my classification. lcr_ger &lt;- fct_collapse(parties_fct, left = c(&quot;Leftists&quot;, &quot;Greens&quot;, &quot;SPD&quot;), centre = c(&quot;CDU&quot;, &quot;CSU&quot;, &quot;FDP&quot;), right = c(&quot;AfD&quot;) ) Another thing you could do – and this is handy for the election data set – is collapsing things together according to their frequency of appearance. In the case of the election data set, this might be handy to lump together the candidates into three groups: Donald Trump, Hillary Clinton, and other. election_data_w_fct %&gt;% mutate(candidate = fct_lump(candidate, n = 2)) ## # A tibble: 18,007 × 8 ## county candidate state pct_report votes total_votes pct lead ## &lt;fct&gt; &lt;fct&gt; &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt; ## 1 Los Angele… Hillary Cli… CA 1 1.65e6 2314275 0.715 Hillary… ## 2 Los Angele… Donald Trump CA 1 5.43e5 2314275 0.234 Hillary… ## 3 Los Angele… Gary Johnson CA 1 5.69e4 2314275 0.0246 Hillary… ## 4 Los Angele… Other CA 1 4.67e4 2314275 0.0202 Hillary… ## 5 Los Angele… Other CA 1 1.35e4 2314275 0.00582 Hillary… ## 6 Cook County Hillary Cli… IL 0.975 1.53e6 2055215 0.744 Hillary… ## 7 Cook County Donald Trump IL 0.975 4.40e5 2055215 0.214 Hillary… ## 8 Cook County Gary Johnson IL 0.975 5.59e4 2055215 0.0272 Hillary… ## 9 Cook County Other IL 0.975 3.05e4 2055215 0.0149 Hillary… ## 10 Harris Cou… Hillary Cli… TX 1 7.06e5 1302887 0.542 Hillary… ## # … with 17,997 more rows The problem here is that Gary Johnson appears as often as the two other candidates (have you ever heard of him?). Hence, fct_lump() cannot decide which levels to lump together. However, it has saved me a couple lines of code: election_data_w_fct %&gt;% mutate(candidate = fct_lump(candidate, n = 2) %&gt;% fct_recode(&quot;Other&quot; = &quot;Gary Johnson&quot;)) ## # A tibble: 18,007 × 8 ## county candidate state pct_report votes total_votes pct lead ## &lt;fct&gt; &lt;fct&gt; &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt; ## 1 Los Angele… Hillary Cli… CA 1 1.65e6 2314275 0.715 Hillary… ## 2 Los Angele… Donald Trump CA 1 5.43e5 2314275 0.234 Hillary… ## 3 Los Angele… Other CA 1 5.69e4 2314275 0.0246 Hillary… ## 4 Los Angele… Other CA 1 4.67e4 2314275 0.0202 Hillary… ## 5 Los Angele… Other CA 1 1.35e4 2314275 0.00582 Hillary… ## 6 Cook County Hillary Cli… IL 0.975 1.53e6 2055215 0.744 Hillary… ## 7 Cook County Donald Trump IL 0.975 4.40e5 2055215 0.214 Hillary… ## 8 Cook County Other IL 0.975 5.59e4 2055215 0.0272 Hillary… ## 9 Cook County Other IL 0.975 3.05e4 2055215 0.0149 Hillary… ## 10 Harris Cou… Hillary Cli… TX 1 7.06e5 1302887 0.542 Hillary… ## # … with 17,997 more rows 7.3 Further links The chapter in R4DS If you want to learn more about factors, consider reading this paper Another tutorial "],["descriptives.html", "Chapter 8 Describing data sets 8.1 Basic descriptives 8.2 Communicating results 8.3 Further links", " Chapter 8 Describing data sets When it comes to the description of data sets, it’s often about just getting a quick feel for the data. While dplyr’s summarize() is a great weapon for summarizing singular variables – and I have already shown you in Chapter @(wrangling) how to do this – you need a hassle-free tool to quickly get an overview. For this use-case, skimr is my personal weapon of choice. It is not part of the tidyverse – yet super-compatible – so we first need to load (and perhaps install) it. if (!&quot;skimr&quot; %in% installed.packages()[,1]) install.packages(&quot;skimr&quot;) library(skimr) 8.1 Basic descriptives skimr is designed around its main function skim(). This function handles tibbles as well as vectors. It returns a so-called skim_df which is basically a tibble with some added columns. However, its biggest strength is the fact that it provides descriptives fast and in a easily comprehensible manner. Moreover, you can then go on and further modify them using tidyverse function. skim(mtcars) # it excels with tibbles as input ## ── Data Summary ──────────────────────── ## Values ## Name mtcars ## Number of rows 32 ## Number of columns 11 ## _______________________ ## Column type frequency: ## numeric 11 ## ________________________ ## Group variables None ## ## ── Variable type: numeric ────────────────────────────────────────────────────── ## skim_variable n_missing complete_rate mean sd p0 p25 p50 ## 1 mpg 0 1 20.1 6.03 10.4 15.4 19.2 ## 2 cyl 0 1 6.19 1.79 4 4 6 ## 3 disp 0 1 231. 124. 71.1 121. 196. ## 4 hp 0 1 147. 68.6 52 96.5 123 ## 5 drat 0 1 3.60 0.535 2.76 3.08 3.70 ## 6 wt 0 1 3.22 0.978 1.51 2.58 3.32 ## 7 qsec 0 1 17.8 1.79 14.5 16.9 17.7 ## 8 vs 0 1 0.438 0.504 0 0 0 ## 9 am 0 1 0.406 0.499 0 0 0 ## 10 gear 0 1 3.69 0.738 3 3 4 ## 11 carb 0 1 2.81 1.62 1 2 2 ## p75 p100 hist ## 1 22.8 33.9 ▃▇▅▁▂ ## 2 8 8 ▆▁▃▁▇ ## 3 326 472 ▇▃▃▃▂ ## 4 180 335 ▇▇▆▃▁ ## 5 3.92 4.93 ▇▃▇▅▁ ## 6 3.61 5.42 ▃▃▇▁▂ ## 7 18.9 22.9 ▃▇▇▂▁ ## 8 1 1 ▇▁▁▁▆ ## 9 1 1 ▇▁▁▁▆ ## 10 4 5 ▇▁▆▁▂ ## 11 4 8 ▇▂▅▁▁ skim(mtcars$mpg) # vectors are fine, too ## ── Data Summary ──────────────────────── ## Values ## Name mtcars$mpg ## Number of rows 32 ## Number of columns 1 ## _______________________ ## Column type frequency: ## numeric 1 ## ________________________ ## Group variables None ## ## ── Variable type: numeric ────────────────────────────────────────────────────── ## skim_variable n_missing complete_rate mean sd p0 p25 p50 p75 ## 1 data 0 1 20.1 6.03 10.4 15.4 19.2 22.8 ## p100 hist ## 1 33.9 ▃▇▅▁▂ Usually, data sets come with columns in different flavors. As an example, we can look at the imdb data set. This set contains categorical and numeric variables: imdb_raw %&gt;% skim() ## ── Data Summary ──────────────────────── ## Values ## Name Piped data ## Number of rows 1000 ## Number of columns 12 ## _______________________ ## Column type frequency: ## character 5 ## numeric 7 ## ________________________ ## Group variables None ## ## ── Variable type: character ──────────────────────────────────────────────────── ## skim_variable n_missing complete_rate min max empty n_unique whitespace ## 1 Title 0 1 2 61 0 999 0 ## 2 Genre 0 1 5 26 0 207 0 ## 3 Description 0 1 42 421 0 1000 0 ## 4 Director 0 1 3 32 0 644 0 ## 5 Actors 0 1 43 77 0 996 0 ## ## ── Variable type: numeric ────────────────────────────────────────────────────── ## skim_variable n_missing complete_rate mean sd p0 p25 ## 1 Rank 0 1 500. 289. 1 251. ## 2 Year 0 1 2013. 3.21 2006 2010 ## 3 Runtime (Minutes) 0 1 113. 18.8 66 100 ## 4 Rating 0 1 6.72 0.945 1.9 6.2 ## 5 Votes 0 1 169808. 188763. 61 36309 ## 6 Revenue (Millions) 128 0.872 83.0 103. 0 13.3 ## 7 Metascore 64 0.936 59.0 17.2 11 47 ## p50 p75 p100 hist ## 1 500. 750. 1000 ▇▇▇▇▇ ## 2 2014 2016 2016 ▃▂▂▃▇ ## 3 111 123 191 ▂▇▅▁▁ ## 4 6.8 7.4 9 ▁▁▃▇▃ ## 5 110799 239910. 1791916 ▇▁▁▁▁ ## 6 48.0 114. 937. ▇▁▁▁▁ ## 7 59.5 72 100 ▁▅▇▇▂ Of course, the type of variable determines the type of operation that can be performed and skimr smartly distinguishes between variable types. 8.1.1 Grouped descriptives You can look at certain descriptives by group. Then, skim() will return descriptives for each group in a row-wise fashion. Just call group_by() before passing the tibble to the skim() call mtcars %&gt;% group_by(cyl) %&gt;% skim() ## ── Data Summary ──────────────────────── ## Values ## Name Piped data ## Number of rows 32 ## Number of columns 11 ## _______________________ ## Column type frequency: ## numeric 10 ## ________________________ ## Group variables cyl ## ## ── Variable type: numeric ────────────────────────────────────────────────────── ## skim_variable cyl n_missing complete_rate mean sd p0 p25 ## 1 mpg 4 0 1 26.7 4.51 21.4 22.8 ## 2 mpg 6 0 1 19.7 1.45 17.8 18.6 ## 3 mpg 8 0 1 15.1 2.56 10.4 14.4 ## 4 disp 4 0 1 105. 26.9 71.1 78.8 ## 5 disp 6 0 1 183. 41.6 145 160 ## 6 disp 8 0 1 353. 67.8 276. 302. ## 7 hp 4 0 1 82.6 20.9 52 65.5 ## 8 hp 6 0 1 122. 24.3 105 110 ## 9 hp 8 0 1 209. 51.0 150 176. ## 10 drat 4 0 1 4.07 0.365 3.69 3.81 ## 11 drat 6 0 1 3.59 0.476 2.76 3.35 ## 12 drat 8 0 1 3.23 0.372 2.76 3.07 ## 13 wt 4 0 1 2.29 0.570 1.51 1.88 ## 14 wt 6 0 1 3.12 0.356 2.62 2.82 ## 15 wt 8 0 1 4.00 0.759 3.17 3.53 ## 16 qsec 4 0 1 19.1 1.68 16.7 18.6 ## 17 qsec 6 0 1 18.0 1.71 15.5 16.7 ## 18 qsec 8 0 1 16.8 1.20 14.5 16.1 ## 19 vs 4 0 1 0.909 0.302 0 1 ## 20 vs 6 0 1 0.571 0.535 0 0 ## 21 vs 8 0 1 0 0 0 0 ## 22 am 4 0 1 0.727 0.467 0 0.5 ## 23 am 6 0 1 0.429 0.535 0 0 ## 24 am 8 0 1 0.143 0.363 0 0 ## 25 gear 4 0 1 4.09 0.539 3 4 ## 26 gear 6 0 1 3.86 0.690 3 3.5 ## 27 gear 8 0 1 3.29 0.726 3 3 ## 28 carb 4 0 1 1.55 0.522 1 1 ## 29 carb 6 0 1 3.43 1.81 1 2.5 ## 30 carb 8 0 1 3.5 1.56 2 2.25 ## p50 p75 p100 hist ## 1 26 30.4 33.9 ▇▃▂▃▃ ## 2 19.7 21 21.4 ▅▂▂▁▇ ## 3 15.2 16.2 19.2 ▂▁▇▃▂ ## 4 108 121. 147. ▇▂▂▆▃ ## 5 168. 196. 258 ▇▁▁▂▂ ## 6 350. 390 472 ▇▅▃▂▅ ## 7 91 96 113 ▃▆▁▇▃ ## 8 110 123 175 ▇▃▁▁▂ ## 9 192. 241. 335 ▇▂▃▁▁ ## 10 4.08 4.16 4.93 ▇▅▃▁▂ ## 11 3.9 3.91 3.92 ▂▂▁▂▇ ## 12 3.12 3.22 4.22 ▃▇▁▁▁ ## 13 2.2 2.62 3.19 ▇▅▇▂▅ ## 14 3.22 3.44 3.46 ▅▂▁▂▇ ## 15 3.76 4.01 5.42 ▇▇▁▁▃ ## 16 18.9 20.0 22.9 ▃▇▇▁▂ ## 17 18.3 19.2 20.2 ▃▇▃▃▇ ## 18 17.2 17.6 18 ▂▂▁▅▇ ## 19 1 1 1 ▁▁▁▁▇ ## 20 1 1 1 ▆▁▁▁▇ ## 21 0 0 0 ▁▁▇▁▁ ## 22 1 1 1 ▃▁▁▁▇ ## 23 0 1 1 ▇▁▁▁▆ ## 24 0 0 1 ▇▁▁▁▁ ## 25 4 4 5 ▁▁▇▁▂ ## 26 4 4 5 ▃▁▇▁▂ ## 27 3 3 5 ▇▁▁▁▁ ## 28 2 2 2 ▇▁▁▁▇ ## 29 4 4 6 ▃▁▇▁▂ ## 30 3.5 4 8 ▇▇▁▁▁ 8.1.2 Modifying the skim() output You can also limit the variables that should be described in the call: mtcars %&gt;% group_by(cyl) %&gt;% skim(mpg, hp, wt) ## ── Data Summary ──────────────────────── ## Values ## Name Piped data ## Number of rows 32 ## Number of columns 11 ## _______________________ ## Column type frequency: ## numeric 3 ## ________________________ ## Group variables cyl ## ## ── Variable type: numeric ────────────────────────────────────────────────────── ## skim_variable cyl n_missing complete_rate mean sd p0 p25 p50 ## 1 mpg 4 0 1 26.7 4.51 21.4 22.8 26 ## 2 mpg 6 0 1 19.7 1.45 17.8 18.6 19.7 ## 3 mpg 8 0 1 15.1 2.56 10.4 14.4 15.2 ## 4 hp 4 0 1 82.6 20.9 52 65.5 91 ## 5 hp 6 0 1 122. 24.3 105 110 110 ## 6 hp 8 0 1 209. 51.0 150 176. 192. ## 7 wt 4 0 1 2.29 0.570 1.51 1.88 2.2 ## 8 wt 6 0 1 3.12 0.356 2.62 2.82 3.22 ## 9 wt 8 0 1 4.00 0.759 3.17 3.53 3.76 ## p75 p100 hist ## 1 30.4 33.9 ▇▃▂▃▃ ## 2 21 21.4 ▅▂▂▁▇ ## 3 16.2 19.2 ▂▁▇▃▂ ## 4 96 113 ▃▆▁▇▃ ## 5 123 175 ▇▃▁▁▂ ## 6 241. 335 ▇▂▃▁▁ ## 7 2.62 3.19 ▇▅▇▂▅ ## 8 3.44 3.46 ▅▂▁▂▇ ## 9 4.01 5.42 ▇▇▁▁▃ When you transform the skim_df into a normal tibble, you can see that additional columns are added: mtcars %&gt;% group_by(cyl) %&gt;% skim(mpg, hp, wt) %&gt;% as_tibble() ## # A tibble: 9 × 13 ## skim_type skim_variable cyl n_missing complete_rate numeric.mean numeric.sd ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 numeric mpg 4 0 1 26.7 4.51 ## 2 numeric mpg 6 0 1 19.7 1.45 ## 3 numeric mpg 8 0 1 15.1 2.56 ## 4 numeric hp 4 0 1 82.6 20.9 ## 5 numeric hp 6 0 1 122. 24.3 ## 6 numeric hp 8 0 1 209. 51.0 ## 7 numeric wt 4 0 1 2.29 0.570 ## 8 numeric wt 6 0 1 3.12 0.356 ## 9 numeric wt 8 0 1 4.00 0.759 ## # … with 6 more variables: numeric.p0 &lt;dbl&gt;, numeric.p25 &lt;dbl&gt;, ## # numeric.p50 &lt;dbl&gt;, numeric.p75 &lt;dbl&gt;, numeric.p100 &lt;dbl&gt;, ## # numeric.hist &lt;chr&gt; Those are: skim_type which denotes the type of variable (usually “categorical” or “numeric”) and skim_variable containing the name of the variable that is summarized. If there are grouping variables, those are included with their original name (in this case, the number of cylinder, “cyl”). Therefore, normal dplyr syntax works in a pipeline with a skim_df: mtcars %&gt;% group_by(cyl) %&gt;% skim(mpg, hp, wt) %&gt;% select(skim_type:numeric.sd) ## ── Data Summary ──────────────────────── ## Values ## Name Piped data ## Number of rows 32 ## Number of columns 11 ## _______________________ ## Column type frequency: ## numeric 3 ## ________________________ ## Group variables cyl ## ## ── Variable type: numeric ────────────────────────────────────────────────────── ## skim_variable cyl n_missing complete_rate mean sd ## 1 mpg 4 0 1 26.7 4.51 ## 2 mpg 6 0 1 19.7 1.45 ## 3 mpg 8 0 1 15.1 2.56 ## 4 hp 4 0 1 82.6 20.9 ## 5 hp 6 0 1 122. 24.3 ## 6 hp 8 0 1 209. 51.0 ## 7 wt 4 0 1 2.29 0.570 ## 8 wt 6 0 1 3.12 0.356 ## 9 wt 8 0 1 4.00 0.759 There are also two handy shortcuts to distinguish between the different types of data. partition() takes a skim_df object and returns a list containing tibbles for each variable type. yank() can be used to deliberately choose a variable type upfront. imdb_raw %&gt;% skim() %&gt;% partition() ## $character ## ## ── Variable type: character ──────────────────────────────────────────────────── ## skim_variable n_missing complete_rate min max empty n_unique whitespace ## 1 Title 0 1 2 61 0 999 0 ## 2 Genre 0 1 5 26 0 207 0 ## 3 Description 0 1 42 421 0 1000 0 ## 4 Director 0 1 3 32 0 644 0 ## 5 Actors 0 1 43 77 0 996 0 ## ## $numeric ## ## ── Variable type: numeric ────────────────────────────────────────────────────── ## skim_variable n_missing complete_rate mean sd p0 p25 ## 1 Rank 0 1 500. 289. 1 251. ## 2 Year 0 1 2013. 3.21 2006 2010 ## 3 Runtime (Minutes) 0 1 113. 18.8 66 100 ## 4 Rating 0 1 6.72 0.945 1.9 6.2 ## 5 Votes 0 1 169808. 188763. 61 36309 ## 6 Revenue (Millions) 128 0.872 83.0 103. 0 13.3 ## 7 Metascore 64 0.936 59.0 17.2 11 47 ## p50 p75 p100 hist ## 1 500. 750. 1000 ▇▇▇▇▇ ## 2 2014 2016 2016 ▃▂▂▃▇ ## 3 111 123 191 ▂▇▅▁▁ ## 4 6.8 7.4 9 ▁▁▃▇▃ ## 5 110799 239910. 1791916 ▇▁▁▁▁ ## 6 48.0 114. 937. ▇▁▁▁▁ ## 7 59.5 72 100 ▁▅▇▇▂ imdb_raw %&gt;% skim() %&gt;% yank(&quot;numeric&quot;) ## ## ── Variable type: numeric ────────────────────────────────────────────────────── ## skim_variable n_missing complete_rate mean sd p0 p25 ## 1 Rank 0 1 500. 289. 1 251. ## 2 Year 0 1 2013. 3.21 2006 2010 ## 3 Runtime (Minutes) 0 1 113. 18.8 66 100 ## 4 Rating 0 1 6.72 0.945 1.9 6.2 ## 5 Votes 0 1 169808. 188763. 61 36309 ## 6 Revenue (Millions) 128 0.872 83.0 103. 0 13.3 ## 7 Metascore 64 0.936 59.0 17.2 11 47 ## p50 p75 p100 hist ## 1 500. 750. 1000 ▇▇▇▇▇ ## 2 2014 2016 2016 ▃▂▂▃▇ ## 3 111 123 191 ▂▇▅▁▁ ## 4 6.8 7.4 9 ▁▁▃▇▃ ## 5 110799 239910. 1791916 ▇▁▁▁▁ ## 6 48.0 114. 937. ▇▁▁▁▁ ## 7 59.5 72 100 ▁▅▇▇▂ 8.1.3 Further descriptives Note that skimr only supports a limited number of measures. If you want to add further descriptives, you can use dplyr::summarize() combined with the across() function to compute the measures. Then you would have to spread the tibbles using tidyr::pivot_longer() and tidyr::pivot_wider() and, finally, join together the tibbles. For the imdb data set and the measures median and variance, this would look like as follows: imdb_raw %&gt;% summarize(across(where(is.numeric), list( median = ~median(.x, na.rm = TRUE), variance = ~var(.x, na.rm = TRUE) ))) %&gt;% pivot_longer( cols = everything(), names_to = c(&quot;skim_variable&quot;, &quot;.value&quot;), names_sep = &quot;_&quot; ) %&gt;% right_join(imdb_raw %&gt;% skim()) ## Joining, by = &quot;skim_variable&quot; ## # A tibble: 12 × 19 ## skim_variable median variance skim_type n_missing complete_rate ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; ## 1 Rank 500. 8.34e+ 4 numeric 0 1 ## 2 Year 2014 1.03e+ 1 numeric 0 1 ## 3 Runtime (Minutes) 111 3.54e+ 2 numeric 0 1 ## 4 Rating 6.8 8.94e- 1 numeric 0 1 ## 5 Votes 110799 3.56e+10 numeric 0 1 ## 6 Revenue (Millions) 48.0 1.07e+ 4 numeric 128 0.872 ## 7 Metascore 59.5 2.96e+ 2 numeric 64 0.936 ## 8 Title NA NA character 0 1 ## 9 Genre NA NA character 0 1 ## 10 Description NA NA character 0 1 ## 11 Director NA NA character 0 1 ## 12 Actors NA NA character 0 1 ## # … with 13 more variables: character.min &lt;int&gt;, character.max &lt;int&gt;, ## # character.empty &lt;int&gt;, character.n_unique &lt;int&gt;, ## # character.whitespace &lt;int&gt;, numeric.mean &lt;dbl&gt;, numeric.sd &lt;dbl&gt;, ## # numeric.p0 &lt;dbl&gt;, numeric.p25 &lt;dbl&gt;, numeric.p50 &lt;dbl&gt;, numeric.p75 &lt;dbl&gt;, ## # numeric.p100 &lt;dbl&gt;, numeric.hist &lt;chr&gt; 8.2 Communicating results By default, when used in RMarkdown documents, skimr outputs quite decent looking tables which look like this: imdb_raw %&gt;% skim() %&gt;% yank(&quot;numeric&quot;) Variable type: numeric skim_variable n_missing complete_rate mean sd p0 p25 p50 p75 p100 hist Rank 0 1.00 500.50 288.82 1.0 250.75 500.50 750.25 1000.00 ▇▇▇▇▇ Year 0 1.00 2012.78 3.21 2006.0 2010.00 2014.00 2016.00 2016.00 ▃▂▂▃▇ Runtime (Minutes) 0 1.00 113.17 18.81 66.0 100.00 111.00 123.00 191.00 ▂▇▅▁▁ Rating 0 1.00 6.72 0.95 1.9 6.20 6.80 7.40 9.00 ▁▁▃▇▃ Votes 0 1.00 169808.26 188762.65 61.0 36309.00 110799.00 239909.75 1791916.00 ▇▁▁▁▁ Revenue (Millions) 128 0.87 82.96 103.25 0.0 13.27 47.98 113.72 936.63 ▇▁▁▁▁ Metascore 64 0.94 58.99 17.19 11.0 47.00 59.50 72.00 100.00 ▁▅▇▇▂ In the RMarkdown chunks above, I had to set my chunk options to render = knitr::normal_print to avoid this behavior. 8.2.1 Tables with knitr::kable() and kableExtra The problem with the default output is the lack of modifiability. The column names, for instance, would suffice for small reports but are inappropriate for something you would want to hand in somewhere or even publish. In RMarkdown, the proper tool for modifying and printing tables is the knitr::kable() function with extended functionalities from the kableExtra package. In the following, I will provide a brief and coarse introduction to the package. It is so coarse that you basically will have to work through the vignettes yourself as for the tables everything is relevant and I am not willing to copy the entire vignettes. So, hit the internet and look at the kableExtra vignette for html and pdf. I will exemplify how it can look like to make a table with descriptives in an HTML-document. I will also add a description for how you can get this into a Word or \\(\\LaTeX\\) document so that you are not limited to RMarkdown when reporting results. The kableExtra package needs to be loaded (or even installed) first: if (!&quot;kableExtra&quot; %in% installed.packages()[,1]) install.packages(&quot;kableExtra&quot;) library(kableExtra) ## ## Attaching package: &#39;kableExtra&#39; ## The following object is masked from &#39;package:dplyr&#39;: ## ## group_rows The basic command is kable(). It takes a tibble and outputs it as an html-table. It looks disgusting. mtcars %&gt;% kable() mpg cyl disp hp drat wt qsec vs am gear carb Mazda RX4 21.0 6 160.0 110 3.90 2.620 16.46 0 1 4 4 Mazda RX4 Wag 21.0 6 160.0 110 3.90 2.875 17.02 0 1 4 4 Datsun 710 22.8 4 108.0 93 3.85 2.320 18.61 1 1 4 1 Hornet 4 Drive 21.4 6 258.0 110 3.08 3.215 19.44 1 0 3 1 Hornet Sportabout 18.7 8 360.0 175 3.15 3.440 17.02 0 0 3 2 Valiant 18.1 6 225.0 105 2.76 3.460 20.22 1 0 3 1 Duster 360 14.3 8 360.0 245 3.21 3.570 15.84 0 0 3 4 Merc 240D 24.4 4 146.7 62 3.69 3.190 20.00 1 0 4 2 Merc 230 22.8 4 140.8 95 3.92 3.150 22.90 1 0 4 2 Merc 280 19.2 6 167.6 123 3.92 3.440 18.30 1 0 4 4 Merc 280C 17.8 6 167.6 123 3.92 3.440 18.90 1 0 4 4 Merc 450SE 16.4 8 275.8 180 3.07 4.070 17.40 0 0 3 3 Merc 450SL 17.3 8 275.8 180 3.07 3.730 17.60 0 0 3 3 Merc 450SLC 15.2 8 275.8 180 3.07 3.780 18.00 0 0 3 3 Cadillac Fleetwood 10.4 8 472.0 205 2.93 5.250 17.98 0 0 3 4 Lincoln Continental 10.4 8 460.0 215 3.00 5.424 17.82 0 0 3 4 Chrysler Imperial 14.7 8 440.0 230 3.23 5.345 17.42 0 0 3 4 Fiat 128 32.4 4 78.7 66 4.08 2.200 19.47 1 1 4 1 Honda Civic 30.4 4 75.7 52 4.93 1.615 18.52 1 1 4 2 Toyota Corolla 33.9 4 71.1 65 4.22 1.835 19.90 1 1 4 1 Toyota Corona 21.5 4 120.1 97 3.70 2.465 20.01 1 0 3 1 Dodge Challenger 15.5 8 318.0 150 2.76 3.520 16.87 0 0 3 2 AMC Javelin 15.2 8 304.0 150 3.15 3.435 17.30 0 0 3 2 Camaro Z28 13.3 8 350.0 245 3.73 3.840 15.41 0 0 3 4 Pontiac Firebird 19.2 8 400.0 175 3.08 3.845 17.05 0 0 3 2 Fiat X1-9 27.3 4 79.0 66 4.08 1.935 18.90 1 1 4 1 Porsche 914-2 26.0 4 120.3 91 4.43 2.140 16.70 0 1 5 2 Lotus Europa 30.4 4 95.1 113 3.77 1.513 16.90 1 1 5 2 Ford Pantera L 15.8 8 351.0 264 4.22 3.170 14.50 0 1 5 4 Ferrari Dino 19.7 6 145.0 175 3.62 2.770 15.50 0 1 5 6 Maserati Bora 15.0 8 301.0 335 3.54 3.570 14.60 0 1 5 8 Volvo 142E 21.4 4 121.0 109 4.11 2.780 18.60 1 1 4 2 This is where kable_styling() comes into play. It gives your table the so-called “twitter bootstrap style” (for html outputs) and allows you to take over control. Read the above-mentioned vignettes for more information on how to use them properly. mtcars %&gt;% kable() %&gt;% kable_styling() mpg cyl disp hp drat wt qsec vs am gear carb Mazda RX4 21.0 6 160.0 110 3.90 2.620 16.46 0 1 4 4 Mazda RX4 Wag 21.0 6 160.0 110 3.90 2.875 17.02 0 1 4 4 Datsun 710 22.8 4 108.0 93 3.85 2.320 18.61 1 1 4 1 Hornet 4 Drive 21.4 6 258.0 110 3.08 3.215 19.44 1 0 3 1 Hornet Sportabout 18.7 8 360.0 175 3.15 3.440 17.02 0 0 3 2 Valiant 18.1 6 225.0 105 2.76 3.460 20.22 1 0 3 1 Duster 360 14.3 8 360.0 245 3.21 3.570 15.84 0 0 3 4 Merc 240D 24.4 4 146.7 62 3.69 3.190 20.00 1 0 4 2 Merc 230 22.8 4 140.8 95 3.92 3.150 22.90 1 0 4 2 Merc 280 19.2 6 167.6 123 3.92 3.440 18.30 1 0 4 4 Merc 280C 17.8 6 167.6 123 3.92 3.440 18.90 1 0 4 4 Merc 450SE 16.4 8 275.8 180 3.07 4.070 17.40 0 0 3 3 Merc 450SL 17.3 8 275.8 180 3.07 3.730 17.60 0 0 3 3 Merc 450SLC 15.2 8 275.8 180 3.07 3.780 18.00 0 0 3 3 Cadillac Fleetwood 10.4 8 472.0 205 2.93 5.250 17.98 0 0 3 4 Lincoln Continental 10.4 8 460.0 215 3.00 5.424 17.82 0 0 3 4 Chrysler Imperial 14.7 8 440.0 230 3.23 5.345 17.42 0 0 3 4 Fiat 128 32.4 4 78.7 66 4.08 2.200 19.47 1 1 4 1 Honda Civic 30.4 4 75.7 52 4.93 1.615 18.52 1 1 4 2 Toyota Corolla 33.9 4 71.1 65 4.22 1.835 19.90 1 1 4 1 Toyota Corona 21.5 4 120.1 97 3.70 2.465 20.01 1 0 3 1 Dodge Challenger 15.5 8 318.0 150 2.76 3.520 16.87 0 0 3 2 AMC Javelin 15.2 8 304.0 150 3.15 3.435 17.30 0 0 3 2 Camaro Z28 13.3 8 350.0 245 3.73 3.840 15.41 0 0 3 4 Pontiac Firebird 19.2 8 400.0 175 3.08 3.845 17.05 0 0 3 2 Fiat X1-9 27.3 4 79.0 66 4.08 1.935 18.90 1 1 4 1 Porsche 914-2 26.0 4 120.3 91 4.43 2.140 16.70 0 1 5 2 Lotus Europa 30.4 4 95.1 113 3.77 1.513 16.90 1 1 5 2 Ford Pantera L 15.8 8 351.0 264 4.22 3.170 14.50 0 1 5 4 Ferrari Dino 19.7 6 145.0 175 3.62 2.770 15.50 0 1 5 6 Maserati Bora 15.0 8 301.0 335 3.54 3.570 14.60 0 1 5 8 Volvo 142E 21.4 4 121.0 109 4.11 2.780 18.60 1 1 4 2 8.2.2 Use case: reporting skimr results 8.2.2.1 Basics for HTML and PDF First, I need to get the results in a proper tibble. I use the mtcars data set. desc_mtcars &lt;- skim(mtcars) %&gt;% as_tibble() First, I select and rename the variables I deem interesting. To save myself some time, I choose variables based on their position: for_table &lt;- desc_mtcars %&gt;% select(Variable = 2, Mean = 5, SD = 6, Minimum = 7, Maximum = 11) %&gt;% mutate(across(where(is.numeric), ~round(., 1))) # round the output Now, I have put it into a tibble that, in theory, be just printed down as a table (you might wish to change the names of the variables, but let’s save this for another time; if you’re willing to: case_when() might be your best shot). I proceed with the kable() call. for_table %&gt;% kable(caption = &quot;Example for a table with some descriptives&quot;) %&gt;% kable_styling( bootstrap_options = &quot;striped&quot;, # several design options full_width = FALSE, # defaults to TRUE position = &quot;center&quot;, # where is it positioned? fixed_thead = TRUE # whether header is fixed when scrolling through -- only for longer tables ) %&gt;% column_spec(1, bold = TRUE, border_right = TRUE) %&gt;% # column specifications can be easily modified footnote(general = &quot;You can add some footnotes with certain signs, too.&quot;, # this is how you add a footnote number = c(&quot;Footnote 1; &quot;, &quot;Footnote 2; &quot;), alphabet = c(&quot;Footnote A; &quot;, &quot;Footnote B; &quot;), symbol = c(&quot;Footnote Symbol 1; &quot;, &quot;Footnote Symbol 2&quot;), general_title = &quot;General: &quot;, number_title = &quot;Type I: &quot;, alphabet_title = &quot;Type II: &quot;, symbol_title = &quot;Type III: &quot;, footnote_as_chunk = T, title_format = c(&quot;italic&quot;, &quot;underline&quot;) ) Table 8.1: Example for a table with some descriptives Variable Mean SD Minimum Maximum mpg 20.1 6.0 10.4 33.9 cyl 6.2 1.8 4.0 8.0 disp 230.7 123.9 71.1 472.0 hp 146.7 68.6 52.0 335.0 drat 3.6 0.5 2.8 4.9 wt 3.2 1.0 1.5 5.4 qsec 17.8 1.8 14.5 22.9 vs 0.4 0.5 0.0 1.0 am 0.4 0.5 0.0 1.0 gear 3.7 0.7 3.0 5.0 carb 2.8 1.6 1.0 8.0 General: You can add some footnotes with certain signs, too. Type I: 1 Footnote 1; 2 Footnote 2; Type II: a Footnote A; b Footnote B; Type III: * Footnote Symbol 1; † Footnote Symbol 2 For \\(\\LaTeX\\) tables this would generally look the same. Depending on whether you knit the RMarkdown file to PDF or HTML, the output will change. You also have some different specification options for \\(\\LaTeX\\) output. 8.2.2.2 Getting it into a Word file Unfortunately, you cannot yet output the tables produced with kable into a proper Word file. In order to achieve this, however, you can use flextable and then export the tables in different formats. flextable is similarly capable as kable. An introduction can be found here. A coarse example follows. First, it needs to be loaded. if (!&quot;flextable&quot; %in% installed.packages()[,1]) install.packages(&quot;flextable&quot;) library(flextable) ## ## Attaching package: &#39;flextable&#39; ## The following objects are masked from &#39;package:kableExtra&#39;: ## ## as_image, footnote ## The following object is masked from &#39;package:purrr&#39;: ## ## compose Then, I can produce the table and export it to DOCX or PPTX format using the save_as_*() function. for_table %&gt;% flextable() %&gt;% save_as_docx(path = &quot;example_table_docx.docx&quot;, sep = &quot;/&quot;) for_table %&gt;% flextable() %&gt;% save_as_pptx(path = &quot;example_table_pptx.pptx&quot;, sep = &quot;/&quot;) Then, further manipulations can be performed in MS Word or PowerPoint (or LibreOffice or whatever). Also, if you have a working version of Word or PowerPoint on your machine, you can use the following commands to start up an interactive session: for_table %&gt;% flextable() %&gt;% print(preview = &quot;docx&quot;) for_table %&gt;% flextable() %&gt;% print(preview = &quot;pptx&quot;) 8.3 Further links An exhaustive introduction to skimr. Intro to flextable. More on kable. "],["visualization.html", "Chapter 9 Visualizations with ggplot2 9.1 The “layered grammar of graphics” 9.2 Exporting graphics 9.3 Further readings", " Chapter 9 Visualizations with ggplot2 “The purpose of visualization is insight, not pictures.” – Ben A. Shneiderman In R, the dominant package for visualizing data is ggplot2 which belongs to the tidyverse. 9.1 The “layered grammar of graphics” ggplot2 works with tibbles and the data needs to be in a tidy format. It builds graphics using “the layered grammar of graphics.” (Wickham 2010) library(tidyverse) library(readxl) publishers &lt;- read_excel(&quot;data/publishers_with_places.xlsx&quot;, sheet = &quot;publishers_a-l&quot;) %&gt;% bind_rows(read_excel(&quot;data/publishers_with_places.xlsx&quot;, sheet = &quot;publishers_m-z&quot;)) %&gt;% separate(city, into = c(&quot;city&quot;, &quot;state&quot;), sep = &quot;,&quot;) %&gt;% select(publisher, city) publishers_filtered &lt;- publishers %&gt;% group_by(city) %&gt;% filter(n() &gt; 5) %&gt;% drop_na() This implies that you start with a base layer – the initial ggplot2 call. ggplot(data = publishers_filtered) The initial call produces an empty coordinate system. It can be filled with additional layers. ggplot(data = publishers_filtered) + geom_bar(aes(x = city)) Unlike the remainder of the tidyverse, ggplot2 uses a + instead of the pipe %&gt;%. If you use the pipe by accident, it will not work and an (informative) error message will appear. # ggplot(data = publishers_filtered) %&gt;% # geom_bar(aes(x = city)) 9.1.1 The layers In general, a call looks like this: ggplot(data = &lt;DATA&gt;) + &lt;GEOM_FUNCTION&gt;(mapping = aes(&lt;MAPPINGS&gt;)) As you might have seen above, I provided the data in the initial ggplot call. Then, when I added the layer – the geom_bar() for a bar plot – I had to provide the mapping – which variables I wanted to plot – using aes(). This is referred to as the aesthetics. In my case, I wanted the cities to be projected to the x-axis. Since I was using geom_bar to create a bar plot, the number of occurrences of the respective cities were automatically counted and depicted on the y-axis. There are more geom_* functions and they all create different plots. Whether you can use them or not depends on the data you have at hand and/or the number of variables you want to plot. In the following, I will give you a brief overview of the most important geoms. 9.1.1.1 One variable If you only want to display one variable, the x- or y-axis, as you choose, will depict the variable’s value. The counterpart will display the frequency or density of those values. 9.1.1.1.1 One variable – discrete Here, the only possible kind of visualization is a bar plot as shown above. If the visualization should look more fancy, e.g., with colored bars, you have several arguments at hand. If they should not be different for different kinds of data, they need to be specified outside the aes(). There are always different arguments and you can look them up using ?&lt;GEOM_FUNCTION&gt; and then looking at the Aesthetics section. Apart from that, you can also look at the ggplot2 cheatsheet. ggplot(data = publishers_filtered) + geom_bar(aes(x = city), fill = &quot;blue&quot;) 9.1.1.1.2 One variable – continuous If you want to display a continuous variable’s distribution of values, you can use a histogram. Its geom_* function is geom_histogram(): load(&quot;data/billboard.rda&quot;) song_tbl &lt;- billboard %&gt;% distinct(artist, track) %&gt;% mutate(song_id = row_number()) rank_tbl &lt;- billboard %&gt;% pivot_longer(cols = starts_with(&quot;wk&quot;), names_to = &quot;week&quot;, names_prefix = &quot;wk&quot;, values_to = &quot;rank&quot;) %&gt;% mutate(week = as.numeric(week), date = date.entered + (week-1) * 7) %&gt;% drop_na() %&gt;% left_join(song_tbl, by = c(&quot;artist&quot;, &quot;track&quot;)) %&gt;% select(song_id, date, week, rank) How does the distribution of songs over the weeks look like? ggplot(data = rank_tbl) + geom_histogram(aes(x = week)) ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. A smoothed histogram is geom_density(): ggplot(data = rank_tbl) + geom_density(aes(x = week)) 9.1.1.2 Two variables In the majority of cases, you will want to display the relationship between two variables, one on the x- and the other one on the y-axis. 9.1.1.2.1 Both continuous county_data_midwest &lt;- socviz::county_data %&gt;% filter(census_region == &quot;Midwest&quot;) %&gt;% drop_na() If both variables are continuous, the easiest option is to use a scatter plot. ggplot(data = county_data_midwest) + geom_point(aes(x = per_dem_2016, y = per_gop_2016)) Here, it might make sense to color the points according to a categorical variable (state, in this case). If so, a legend is added which maps the colors to their respective values. ggplot(data = county_data_midwest) + geom_point(aes(x = per_dem_2016, y = per_gop_2016, color = state)) Since I look at the relationship between votes for the Republicans and the Democrats, and the U.S. is a two-party system, there is a fairly clear relationship between them both. This can also be depicted using geom_smooth(): ggplot(data = county_data_midwest) + geom_smooth(aes(x = per_dem_2016, y = per_gop_2016, color = state)) ## `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; Here, color = state has a different effect: each dimension of the categorical variable gets its own line. If you do not want it to be smoothed, just use geom_line(). ggplot(data = county_data_midwest) + geom_line(aes(x = per_dem_2016, y = per_gop_2016), color = &quot;grey&quot;) 9.1.1.2.2 Discrete X, continuous Y In this case, different categories of data will be put on the x-axis and some of their properties will be displayed on the y-axis. The probably most prominent example for this type of plot is a box plot: ggplot(data = county_data_midwest) + geom_boxplot(aes(x = state, y = per_gop_2016)) 9.1.1.2.3 Both discrete It is rarely the case that you want to depict two categorical variables in one plot. If so, you can use geom_jitter(). It is related to geom_point(). The difference is that with geom_jitter(), a little bit of noise is added to the dots, making them appear distinct. ggplot(data = county_data_midwest) + geom_jitter(aes(x = state, y = winner)) As opposed to: ggplot(data = county_data_midwest) + geom_point(aes(x = state, y = winner)) 9.1.2 Making them “publishable” So far, I have only added one layer to the plot. This suffices for the most basic visualizations. The good thing about R and RMarkdown is, however, that you can write entire publications only using their means. Hence, the plots need to look awesome. This section is dedicated to how you can achieve this. First, I will touch upon how you can make them look good using scales. labs() allow you to add titles, captions, and axis labels. Finally, facet_* allows you to plot multiple plots into one. 9.1.2.1 Scales Scales can be used to take control of how the data’s values are mapped to the aesthetic’s visual values. You can find a more exhaustive tutorial on them here. scale_*_continuous – for dealing with continuous values. (you can find an exhaustive list of colors in R here) ggplot(data = county_data_midwest) + geom_point(aes(x = per_dem_2016, y = per_gop_2016, color = white)) + scale_x_continuous(limits = c(0, 1)) + scale_y_continuous(limits = c(0, 1)) + scale_color_gradient(low = &quot;green&quot;, high = &quot;red&quot;) scale_*_discrete – for dealing with discrete values scale_*_manual – manually mapping discrete values to visual values socviz::county_data %&gt;% filter(state %in% c(&quot;IA&quot;, &quot;IL&quot;, &quot;IN&quot;, &quot;KS&quot;)) %&gt;% ggplot() + geom_point(aes(x = per_dem_2016, y = per_gop_2016, color = state)) + scale_color_manual(values = c(&quot;IA&quot; = &quot;blue&quot;, &quot;IL&quot; = &quot;green&quot;, &quot;IN&quot; = &quot;red&quot;, &quot;KS&quot; = &quot;purple&quot;), name = &quot;State&quot;, breaks = waiver(), labels = c(&quot;Iowa&quot;, &quot;Illinois&quot;, &quot;Indiana&quot;, &quot;Kansas&quot;)) ## Warning: Removed 4 rows containing missing values (geom_point). 9.1.2.2 Adding titles, captions, etc. Now you have modified the scales and colors – there is a lot more to be modified if you want to – but you have not added a meaningful title, a nice caption (where were the data obtained?), and the axes do not have proper names, too. This can be achieved using labs() (which is the abbreviation for labels). socviz::county_data %&gt;% filter(state %in% c(&quot;IA&quot;, &quot;IL&quot;, &quot;IN&quot;, &quot;KS&quot;)) %&gt;% ggplot() + geom_point(aes(x = per_dem_2016, y = per_gop_2016, color = state)) + scale_color_manual(values = c(&quot;IA&quot; = &quot;blue&quot;, &quot;IL&quot; = &quot;green&quot;, &quot;IN&quot; = &quot;red&quot;, &quot;KS&quot; = &quot;purple&quot;), name = &quot;State&quot;, breaks = waiver(), labels = c(&quot;Iowa&quot;, &quot;Illinois&quot;, &quot;Indiana&quot;, &quot;Kansas&quot;)) + scale_x_continuous(limits = c(0, 1)) + scale_y_continuous(limits = c(0, 1)) + ggtitle(&quot;Relationship between percentages of votes for Democrats and Republicans in selected states in the Midwest&quot;) + xlab(&quot;Percentage of votes for the Democrats in 2016&quot;) + ylab(&quot;Percentage of votes for the Republicans in 2016&quot;) ## Warning: Removed 4 rows containing missing values (geom_point). Well, that doesn’t look good, the title is too long. Inserting \\n – for new line – will do the trick. socviz::county_data %&gt;% filter(state %in% c(&quot;IA&quot;, &quot;IL&quot;, &quot;IN&quot;, &quot;KS&quot;)) %&gt;% ggplot() + geom_point(aes(x = per_dem_2016, y = per_gop_2016, color = state)) + scale_color_manual(values = c(&quot;IA&quot; = &quot;blue&quot;, &quot;IL&quot; = &quot;green&quot;, &quot;IN&quot; = &quot;red&quot;, &quot;KS&quot; = &quot;purple&quot;), name = &quot;State&quot;, breaks = waiver(), labels = c(&quot;Iowa&quot;, &quot;Illinois&quot;, &quot;Indiana&quot;, &quot;Kansas&quot;)) + scale_x_continuous(limits = c(0, 1)) + scale_y_continuous(limits = c(0, 1)) + ggtitle(&quot;Relationship between percentages of votes for Democrats \\nand Republicans in selected states in the Midwest&quot;) + xlab(&quot;Percentage of votes for the Democrats in 2016&quot;) + ylab(&quot;Percentage of votes for the Republicans in 2016&quot;) ## Warning: Removed 4 rows containing missing values (geom_point). However, providing it with three different layers just for labeling is pretty tedious. This is where labs() comes in handy. socviz::county_data %&gt;% filter(state %in% c(&quot;IA&quot;, &quot;IL&quot;, &quot;IN&quot;, &quot;KS&quot;)) %&gt;% ggplot() + geom_point(aes(x = per_dem_2016, y = per_gop_2016, color = state)) + scale_color_manual(values = c(&quot;IA&quot; = &quot;blue&quot;, &quot;IL&quot; = &quot;green&quot;, &quot;IN&quot; = &quot;red&quot;, &quot;KS&quot; = &quot;purple&quot;), name = &quot;State&quot;, breaks = waiver(), labels = c(&quot;Iowa&quot;, &quot;Illinois&quot;, &quot;Indiana&quot;, &quot;Kansas&quot;)) + scale_x_continuous(limits = c(0, 1)) + scale_y_continuous(limits = c(0, 1)) + labs(title = &quot;Relationship between percentages of votes for Democrats \\nand Republicans in selected states in the Midwest&quot;, caption = &quot;Data obtained from the socviz R package&quot;, x = &quot;Percentage of votes for the Democrats in 2016&quot;, y = &quot;Percentage of votes for the Republicans in 2016&quot;) ## Warning: Removed 4 rows containing missing values (geom_point). 9.1.2.3 Facets The original data set consists of four different census regions. If I were to compare them, I could color them accordingly. socviz::county_data %&gt;% drop_na() %&gt;% ggplot() + geom_point(aes(x = per_dem_2016, y = per_gop_2016, color = census_region)) + scale_x_continuous(limits = c(0, 1)) + scale_y_continuous(limits = c(0, 1)) + scale_color_discrete() Despite the coloring according to the different states, it is still hard to assess whether there really are differences. Apart from that, I would like to assess the impact the percentage of white people in the population has. This would be easier if I put them into individual graphs. I can achieve this using so-called facets. Facets enable me to divide the plot into subplots based on categorical variables. facet_wrap() puts them into a rectangular layout. The categorical variable needs to be provided prefixed with a tilde ~, nrow determines the number of rows. socviz::county_data %&gt;% drop_na() %&gt;% ggplot() + geom_point(aes(x = per_dem_2016, y = per_gop_2016, color = white)) + scale_x_continuous(limits = c(0, 1)) + scale_y_continuous(limits = c(0, 1)) + scale_color_gradient(low = &quot;green&quot;, high = &quot;red&quot;) + facet_wrap(~census_region, nrow = 2) Apart from that, I can also spread it out using two different variables. Here, I will look at differences in the distribution of males and females in the counties split up by who won in 2016 and 2012. This can be achieved using facet_grid(categorical_variable_1~categorical_variable_2). The former one will be out into rows, the latter into columns. socviz::county_data %&gt;% drop_na() %&gt;% ggplot() + geom_point(aes(x = per_dem_2016, y = per_gop_2016, color = white)) + scale_x_continuous(limits = c(0, 1)) + scale_y_continuous(limits = c(0, 1)) + scale_color_gradient(low = &quot;green&quot;, high = &quot;red&quot;) + facet_grid(winner~winner12) If you want to facet using only one variable, put a dot at where the other variable would stand otherwise… socviz::county_data %&gt;% drop_na() %&gt;% ggplot() + geom_point(aes(x = per_dem_2016, y = per_gop_2016, color = white)) + scale_x_continuous(limits = c(0, 1)) + scale_y_continuous(limits = c(0, 1)) + scale_color_gradient(low = &quot;green&quot;, high = &quot;red&quot;) + facet_grid(.~winner) … or just use facet_wrap(). 9.2 Exporting graphics If you include the graphics in an RMarkdown document, make sure you use the proper chunk options (i.e., {r echo=FALSE, message=FALSE, warning=FALSE}). If you, however, want to export it and put it into an MS Word document or so, you can just use the ggsave() function. By default, it just takes the last plot that has been created and saves it to a path that needs to be specified. If it contains a file extension, ggsave() just uses this one. ggplot(mtcars, aes(mpg, wt)) + geom_point() ggsave(&quot;mtcars.pdf&quot;) #save it to pdf ggsave(&quot;mtcars.png&quot;) #save it to png ggsave(&quot;mtcars.pdf&quot;, width = 4, height = 4) #specify width and height -- in inches by default ggsave(&quot;mtcars.pdf&quot;, width = 20, height = 20, units = &quot;cm&quot;) #change unit using the units argument 9.3 Further readings ggplot2 – the book. The graphic cookbook for R. Another tutorial. The ggsave() function in further detail. References "],["markdown.html", "Chapter 10 Writing academic papers with RMarkdown 10.1 Introduction 10.2 Further resources", " Chapter 10 Writing academic papers with RMarkdown 10.1 Introduction When it comes to communicating results, RStudio comes with the knitr package and RMarkdown. It is practical insofar as it allows you to combine both your code and its results, and the text you write to accompany it. Several output formats are supported, for instance PDF, docx, slideshows, HTML, etc. RMarkdown files have the suffix .Rmd. I have prepared a basic example RMD document and the corresponding PDF (knit using tinytex), HTML, and MS WORD versions. You can download the zip file from my Dropbox. I invite you to have a look at the documents and how the RMD file translates to the different output formats. 10.2 Further resources The vignette for kableExtra The YAML fieldguide A comprehensive introduction to the new visual editor An introduction to  formulas A formula editor "],["functionalprogramming.html", "Chapter 11 Functional programming and iterations 11.1 Flow control 11.2 Functions 11.3 Iteration 11.4 Further links", " Chapter 11 Functional programming and iterations So far, you have learned heaps of data wrangling and analyses, but no real customization of R. This will change now, as you will be introduced to functions. Furthermore, the operations have only been applied to one singular object (read vector or data.frame/tibble). Iteration means that you perform the same operation on multiple objects/data sets/you name it. Today’s session will all be about following the DRY principle. DRY stands for Don’t Repeat Yourself. “Why not?,” you may ask. Well, the problem with copy-and-pasting code is that you have to change all the variable names in every instance of your code. RStudio has a nice Search-and-Replace function which might facilitate that, but this practice still bears the danger of writing code that contains errors. This is where you will need to make use of the tools that R offers to iterate over a couple of elements, perform operations on them, and return the results. An example: example_strings &lt;- c(&quot;this&quot;, &quot;is&quot;, &quot;how&quot;, &quot;a&quot;, &quot;for&quot;, &quot;loop&quot;, &quot;works&quot;) for (i in seq_along(example_strings)) { print(example_strings[[i]]) } ## [1] &quot;this&quot; ## [1] &quot;is&quot; ## [1] &quot;how&quot; ## [1] &quot;a&quot; ## [1] &quot;for&quot; ## [1] &quot;loop&quot; ## [1] &quot;works&quot; Another option – from the tidyverse – is the purrr package: library(tidyverse) walk(example_strings, print) ## [1] &quot;this&quot; ## [1] &quot;is&quot; ## [1] &quot;how&quot; ## [1] &quot;a&quot; ## [1] &quot;for&quot; ## [1] &quot;loop&quot; ## [1] &quot;works&quot; So, what has this code done? In both cases, it has taken the function print() and applied it to every value of our vector. Copying-and-pasting would have looked like this: print(example_strings[[1]]) ## [1] &quot;this&quot; print(example_strings[[2]]) ## [1] &quot;is&quot; print(example_strings[[3]]) ## [1] &quot;how&quot; print(example_strings[[4]]) ## [1] &quot;a&quot; print(example_strings[[5]]) ## [1] &quot;for&quot; print(example_strings[[6]]) ## [1] &quot;loop&quot; print(example_strings[[7]]) ## [1] &quot;works&quot; print(example_strings[[7]]) ## [1] &quot;works&quot; Damn, I pasted the last instance twice. In this case, the mistake is obvious, but oftentimes it is not. In the following, I will provide you a more extensive introduction into conditional statements, functions, loops, and the purrr package. 11.1 Flow control Sometimes you want your code to only run in specific cases. For mutate(), I have already showed you conditional imputation of values with case_when(). A more generalized approach for conditionally running code in R are if statements. They look as follows: if (conditional_statement evaluates to TRUE) { do_something } They also have an extension – if…else: if (conditional_statement evaluates to TRUE) { do_something } else { do_something_else } Imagine that I want R to tell me whether a number it draws is smaller than or equal to five: set.seed(123) x &lt;- sample(10, 1) if (x &lt;= 5) { print(&quot;x is smaller than or equals 5&quot;) } ## [1] &quot;x is smaller than or equals 5&quot; In this case, x is 3, so the if statement returns something. If this is not the case, nothing happens: set.seed(1234) x &lt;- sample(10, 1) if (x &lt;= 5) { print(&quot;x is smaller than or equals 5&quot;) } Now I could extend it by another if statement: if (x &gt; 5) { print(&quot;x is greater than 5&quot;) } ## [1] &quot;x is greater than 5&quot; But else allows me to take a shortcut if (x &lt;= 5) { print(&quot;x is smaller than or equals 5&quot;) } else { print(&quot;x is greater than 5&quot;) } ## [1] &quot;x is greater than 5&quot; Please note that the condition inside the if statement needs to be a vector of type logical (hence, either TRUE or FALSE). Apart from that, only the first value will be used: if (c(TRUE, FALSE, TRUE)) { print(&quot;example&quot;) } ## Warning in if (c(TRUE, FALSE, TRUE)) {: the condition has length &gt; 1 and only ## the first element will be used ## [1] &quot;example&quot; 11.2 Functions So far, every call you have made within R contained a function. Even the most basic operations, such as c() for building vectors, rely on functions. Functions are the verbs of R, they do something to your objects. Hence, you as someone who obeys the principles of DRY can make good use of them. Whenever you need to copy code to perform certain tasks to an object, you can also put those tasks into a function and just provide the function with the objects. Imagine you want to rescale some variables in a tibble (an example I took from R4DS (Wickham and Grolemund 2016)): library(tidyverse) set.seed(1234) df &lt;- tibble( a = rnorm(10), b = rnorm(10), c = rnorm(10), d = rnorm(10) ) df$a &lt;- (df$a - min(df$a, na.rm = TRUE)) / (max(df$a, na.rm = TRUE) - min(df$a, na.rm = TRUE)) df$b &lt;- (df$b - min(df$b, na.rm = TRUE)) / (max(df$b, na.rm = TRUE) - min(df$b, na.rm = TRUE)) df$c &lt;- (df$c - min(df$c, na.rm = TRUE)) / (max(df$c, na.rm = TRUE) - min(df$c, na.rm = TRUE)) df$d &lt;- (df$d - min(df$d, na.rm = TRUE)) / (max(df$d, na.rm = TRUE) - min(df$d, na.rm = TRUE)) Given that you now know how to loop over the tibble, you can certainly reduce the amount of copy-pasting here. df &lt;- tibble( a = rnorm(10), b = rnorm(10), c = rnorm(10), d = rnorm(10) ) for (i in seq_along(df)) { df[[i]] &lt;- (df[[i]] - min(df[[i]], na.rm = TRUE)) / (max(df[[i]], na.rm = TRUE) - min(df[[i]], na.rm = TRUE)) } However, the operation within the loop is generalizable: it always only takes a vector of numeric values as input, performs some actions on them and returns another vector of the same length, but rescaled into a range from 0 to 1. Hence, the operation fulfills the requirements for putting it into a function. Doing so has some advantages: If an error occurs, you can simply change the function in one place – when you define it – instead of changing all the occurrences in your code It will certainly make your code easier to read – rescale0to1 is a more concise description than (x - min(x, na.rm = TRUE)) / (max(x, na.rm = TRUE) - min(x. na.rm = TRUE)) (–&gt; you see what I did here? I already replaced the arguments with a generic variable. You can use it to write the function yourself (Exercise 1).) 11.2.1 Writing your own functions When you define functions in R, you need to follow a certain structure: function_name &lt;- function(argument_1, argument_2, argument_n) { function body } The function_name is the thing you will call (e.g., mean()). In general, it should be a verb, it should be concise, and it should be in_snakecase. The arguments are what you need to provide the function with (e.g., mean(1:10)). The function body contains the operations which are performed to the arguments. It can contain other functions as well – which need to be defined beforehand (e.g., sum(1:10) / length(1:10))). It is advisable to split up the function body into as little pieces as you can. 11.2.2 An example: Roulette In the following, I will guide you through a quick example on how you could use functions to play an extremely basic game of Roulette with R. You provide it with two values (how much you bet and which number you choose) and R takes care of the rest. So what does the function need to do? First, it needs to draw a number between 0 and 36. Second, it needs to compare the bet and its corresponding number. Third, it needs to return the respective result. play_roulette &lt;- function(bet, number) { draw &lt;- sample(0:36, 1) tibble( winning_number = draw, your_number = number, your_bet = bet, your_return = if (number == draw) { bet * 36 } else { 0 } ) } play_roulette(bet = 1, number = 35) ## # A tibble: 1 × 4 ## winning_number your_number your_bet your_return ## &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 15 35 1 0 But how to make sure that I do not bet on a number which I cannot bet on (i.e., numbers greater than 36)? Or, put differently, how to forbid values? Use stop(). Besides, how to set default values for the arguments? Just use argument = default. play_roulette_restricted &lt;- function(bet = 1, number) { if (number &gt; 36) stop(&quot;You can only bet on numbers between 0 and 36.&quot;) draw &lt;- sample(0:36, 1) tibble( winning_number = draw, your_number = number, your_bet = bet, your_return = if (number == draw) { bet * 36 } else { 0 } ) #return(tbl_return) } play_roulette_restricted(number = 35) ## # A tibble: 1 × 4 ## winning_number your_number your_bet your_return ## &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 35 1 0 The function returns the results of the last call, i.e., the tibble. If you want to be more concrete about what it should return, use return(): play_roulette_basic &lt;- function(bet = 1, number) { if (number &gt; 36) stop(&quot;You can only bet on numbers between 0 and 36.&quot;) draw &lt;- sample(0:36, 1) if (number == draw) { return(str_c(&quot;Nice, you won&quot;, as.character(bet * 36), &quot;Dollars&quot;, sep = &quot; &quot;)) } else { return(&quot;I&#39;m sorry, you lost.&quot;) } } play_roulette_basic(number = 35) ## [1] &quot;I&#39;m sorry, you lost.&quot; 11.2.3 Functional programming with tidyverse functions The majority ofdplyr verbs uses so-called tidy evaluation which is a framework for controlling how expressions and variables in your code are evaluated by the tidyverse functions. The two main things here are data masking and tidy selection. The former facilitates computing on values within the data set and refers to functions such as filter(), where you can just type in variable names instead of tediously typing name_of_df$var_name. The latter aims to facilitate working with the columns in the data set. It is provided by the tidyselect package and allows you, for instance, to work with code such as tbl %&gt;% select(starts_with(\"a\")). More examples can be acquired using ?dplyr_tidy_select. I will not go into detail here but rather stick to what implications this has to you. If you are interested in the theoretical underpinnings, read the chapter on “Metaprogramming” in Advanced R by Hadley Wickham. 11.2.3.1 Providing the variable in the function call If your function takes a user-supplied variable as an argument, you need to consider this arguments in the pipeline. For instance, the following function calculates the mean, median, and standard deviation of a variable. my_summary &lt;- function(tbl, var) { tbl %&gt;% summarize( mean = mean({{ var }}), median = median({{ var }}), sd = sd({{ var }}) ) } mtcars %&gt;% my_summary(cyl) ## mean median sd ## 1 6.1875 6 1.785922 If the variable names are supplied in a character vector, you need all_of(): summarize_mean &lt;- function(data, vars) { data %&gt;% summarize(n = n(), across({{ vars }}, mean)) } mtcars %&gt;% group_by(cyl) %&gt;% summarize_mean(all_of(c(&quot;hp&quot;, &quot;mpg&quot;))) %&gt;% glimpse() ## Rows: 3 ## Columns: 4 ## $ cyl &lt;dbl&gt; 4, 6, 8 ## $ n &lt;int&gt; 11, 7, 14 ## $ hp &lt;dbl&gt; 82.63636, 122.28571, 209.21429 ## $ mpg &lt;dbl&gt; 26.66364, 19.74286, 15.10000 Another handy thing is changing the variable names in the output depending on the input names. Here, you can use glue syntax and :=: my_summary_w_names &lt;- function(tbl, var){ tbl %&gt;% summarize( &quot;mean_{{ var }}&quot; := mean({{ var }}), &quot;median_{{ var }}&quot; := median({{ var }}), &quot;sd_{{ var }}&quot; := sd({{ var }}) ) } mtcars %&gt;% my_summary_w_names(cyl) ## mean_cyl median_cyl sd_cyl ## 1 6.1875 6 1.785922 Find more on programming with dplyr in this vignette. 11.2.4 Further readings If you want to learn more about functional programming, check out the following resources: The R4DS chapter A basic tutorial A book chapter about control-flow and functions Hadley on functional programming 11.3 Iteration Strictly speaking, there are three kinds of loops: for, repeat, and while. I will touch upon for and while, because they are more straight-forward than repeat. repeat loops will repeat a task until you tell it to stop by hitting the escape button or adding a condition up front. Interactive programming – hitting the escape button to break a loop – is no desired practice and while loops have internalized the condition already. Hence, repeat loops do not appear to have any advantage and I can leave them out deliberately. 11.3.1 for loops for loops are the sort of loops you will have to work with more often as they allow you to loop over a predefined number of elements. For this sake, I will briefly revise how you index vectors, lists, and tibbles. The ith element of a vector can be accessed by using either [[i]] or [i]. The ith element of a list can be obtained by using [[i]] – [i] would return a sub-list instead of the element. The second element of the ith element in a list (if it were a vector or a list) can be obtained using [[i]][[2]] etc. The ith column of a tibble can be accessed as a vector using [[i]]. The second value of the ith column of a tibble can be accessed using [[i]][[2]] How does that matter for for loops? Remember the example I showed you in the beginning? All a for loop does is iterating over a vector of values and imputing them instead of a placeholder. example_strings &lt;- c(&quot;this&quot;, &quot;is&quot;, &quot;how&quot;, &quot;a&quot;, &quot;for&quot;, &quot;loop&quot;, &quot;works&quot;) for (i in seq_along(example_strings)) { print(example_strings[[1]]) } ## [1] &quot;this&quot; ## [1] &quot;this&quot; ## [1] &quot;this&quot; ## [1] &quot;this&quot; ## [1] &quot;this&quot; ## [1] &quot;this&quot; ## [1] &quot;this&quot; seq_along(example_strings) # seq_along looks like this ## [1] 1 2 3 4 5 6 7 # hence, the first iteration looks like this. print(example_strings[[seq_along(example_strings)[[1]]]]) ## [1] &quot;this&quot; # translates to print(example_strings[[1]]) ## [1] &quot;this&quot; However, this course is about data analysis. So, I have a tibble with different cars and I want to perform some operations on some columns. In this case, I want the average value for every column where it makes sense. cars_tbl &lt;- mtcars %&gt;% rownames_to_column(var = &quot;model_name&quot;) %&gt;% select(mpg, cyl, disp, hp, gear) glimpse(cars_tbl) ## Rows: 32 ## Columns: 5 ## $ mpg &lt;dbl&gt; 21.0, 21.0, 22.8, 21.4, 18.7, 18.1, 14.3, 24.4, 22.8, 19.2, 17.8,… ## $ cyl &lt;dbl&gt; 6, 6, 4, 6, 8, 6, 8, 4, 4, 6, 6, 8, 8, 8, 8, 8, 8, 4, 4, 4, 4, 8,… ## $ disp &lt;dbl&gt; 160.0, 160.0, 108.0, 258.0, 360.0, 225.0, 360.0, 146.7, 140.8, 16… ## $ hp &lt;dbl&gt; 110, 110, 93, 110, 175, 105, 245, 62, 95, 123, 123, 180, 180, 180… ## $ gear &lt;dbl&gt; 4, 4, 4, 3, 3, 3, 3, 4, 4, 4, 4, 3, 3, 3, 3, 3, 3, 4, 4, 4, 3, 3,… output &lt;- double(length = ncol(cars_tbl)) output &lt;- set_names(output, colnames(cars_tbl)) # names don&#39;t look good -- for loop and change them to &quot;mean_*&quot; using the paste-function for (i in seq_along(cars_tbl)) { output[[i]] &lt;- mean(cars_tbl[[i]]) } If you wanted to loop over a tibble and just perform operations to certain variables using dplyr syntax, you could also draw the variable names from a vector. However, for this a slightly different command needs to be used, you cannot simply refer to the variable name in a pipeline. You need to index into the .data pronoun. relevant_columns &lt;- c(&quot;mpg&quot;, &quot;cyl&quot;, &quot;disp&quot;, &quot;hp&quot;, &quot;gear&quot;) for (var in relevant_columns) { mtcars %&gt;% count(.data[[var]]) %&gt;% print() } ## mpg n ## 1 10.4 2 ## 2 13.3 1 ## 3 14.3 1 ## 4 14.7 1 ## 5 15.0 1 ## 6 15.2 2 ## 7 15.5 1 ## 8 15.8 1 ## 9 16.4 1 ## 10 17.3 1 ## 11 17.8 1 ## 12 18.1 1 ## 13 18.7 1 ## 14 19.2 2 ## 15 19.7 1 ## 16 21.0 2 ## 17 21.4 2 ## 18 21.5 1 ## 19 22.8 2 ## 20 24.4 1 ## 21 26.0 1 ## 22 27.3 1 ## 23 30.4 2 ## 24 32.4 1 ## 25 33.9 1 ## cyl n ## 1 4 11 ## 2 6 7 ## 3 8 14 ## disp n ## 1 71.1 1 ## 2 75.7 1 ## 3 78.7 1 ## 4 79.0 1 ## 5 95.1 1 ## 6 108.0 1 ## 7 120.1 1 ## 8 120.3 1 ## 9 121.0 1 ## 10 140.8 1 ## 11 145.0 1 ## 12 146.7 1 ## 13 160.0 2 ## 14 167.6 2 ## 15 225.0 1 ## 16 258.0 1 ## 17 275.8 3 ## 18 301.0 1 ## 19 304.0 1 ## 20 318.0 1 ## 21 350.0 1 ## 22 351.0 1 ## 23 360.0 2 ## 24 400.0 1 ## 25 440.0 1 ## 26 460.0 1 ## 27 472.0 1 ## hp n ## 1 52 1 ## 2 62 1 ## 3 65 1 ## 4 66 2 ## 5 91 1 ## 6 93 1 ## 7 95 1 ## 8 97 1 ## 9 105 1 ## 10 109 1 ## 11 110 3 ## 12 113 1 ## 13 123 2 ## 14 150 2 ## 15 175 3 ## 16 180 3 ## 17 205 1 ## 18 215 1 ## 19 230 1 ## 20 245 2 ## 21 264 1 ## 22 335 1 ## gear n ## 1 3 15 ## 2 4 12 ## 3 5 5 Every for loop consists of three components: Output: In the beginning, I create a double vector output &lt;- double(length = ncol(cars_tbl)). As you can see here, I determine the length of the vector in the beginning. This is due to efficiency: if you were to grow the vector by every iteration (using c), the loop becomes very slow. This is especially important if you work with large data sets. Sequence: i in seq_along(cars_tbl) tells the for loop what to loop over. Body: output[[i]] &lt;- mean(cars_tbl[[i]]). The actual code. Performs the operation on the respective column cars_tbl[[whatever 'i']] and stores the resulting value in the pre-defined output vector at position i. One problem with for loops is that they are considered slow. They are not, at least not if you stick to the following rules: Always pre-allocate space – make sure that R does not have to expand your objects Do as much as you can outside the loop – every operation inside the loop will be repeated every time the loop is repeated 11.3.1.1 Variations In general, you will come across three different problems with for loops. Modifying an existing object Length of output is unknown Sequences are of unknown length 11.3.1.1.1 Modifying the existing object Remember the for loop with the cars_tbl? I could have performed the same operation storing it in the very same tibble again: for (i in seq_along(cars_tbl)) { cars_tbl[[i]] &lt;- mean(cars_tbl[[i]]) } However, in this case it preserves the number of rows and changes all the values to the respective measure. Hence, I need to slice() it. cars_tbl_sliced &lt;- cars_tbl %&gt;% slice(1) 11.3.1.1.2 Length of output is unknown Sometimes, you do not know how long your output object is. This is, for instance, if you simulate vectors of random length. Normally, you would just put the values into a vector. However, if you do not know the length, then you would have to ask R to grow the vector every iteration. But this is extremely inefficient. For this, the solution is lists. You always know how many iterations your loop will have. Hence, you can create a list of this exact length and then just store the results in the list (as lists do not care about the length of the singular elements). Afterwards, you can unlist() or flatten_*() the list into a vector. 11.3.1.1.3 Unknown sequence length Seldom, you also do not know how long your input sequence is. Instead, you want to loop until a certain condition is met. This is where while loops come in handy (but this is the only use case I could think of). The basic structure of while loops is as follows: while (condition) { code } What could an example look like?6 The following loop keeps running until three heads appeared in a row and the condition is met. Please note that both vectors which are to be modified within the loop – indicator and head – need to be created beforehand. If I had not created head beforehand, the loop would not have started because there would not have been any vector to assess the length. indicator &lt;- 0 head &lt;- c() while (length(head) &lt; 3) { if (sample(2, 1) == 1) { x &lt;- &quot;head&quot; } else { x &lt;- &quot;tail&quot; } if (x == &quot;head&quot;) { head &lt;- c(head, 1) } else { length(head) &lt;- 0 } indicator &lt;- indicator + 1 } 11.3.2 purrr::map() Loops are good because they make everything very explicit. However, it is often tedious to type. The purrr package provides functions which enable you to iterate over vectors, data frames/tibbles, and lists. Apart from that, it has a lot of functions to work with lists as well. I will only cover the former functions. If you are interested in using purrr for working with lists, check out this extensive tutorial by Jenny Bryan. In the beginning of this chapter, I used the walk() function. This function is related to map() as it iterates over a vector and applies a function to its respective elements. The difference is that walk() doesn’t store the results, map() does. 11.3.2.1 The basics The structure of the map() function looks like this: map(vector or list, function(, if you need it, additional arguments of function)) map() always returns a list. If you want the output to be in a different format, there are different, type-specific map() functions. map_dfr() returns a data frame – by binding the rows map_dfc() returns a data frame – by binding the columns map_dbl() returns a double vector map_chr() returns a character vector map_lgl() returns a logical vector In the following I will demonstrate the function of map() with a simple example. The basic vector I will map over is: example_dbl &lt;- c(1.5, 1.3, 1.8, 1.9, 2.3) In the first example, I just add 10 to the vector. In order to do so, I first need to create a function which adds 10. add_10 &lt;- function(x) { x + 10 } map(example_dbl, add_10) ## [[1]] ## [1] 11.5 ## ## [[2]] ## [1] 11.3 ## ## [[3]] ## [1] 11.8 ## ## [[4]] ## [1] 11.9 ## ## [[5]] ## [1] 12.3 map_dbl(example_dbl, add_10) ## [1] 11.5 11.3 11.8 11.9 12.3 map_chr(example_dbl, add_10) # does not make sense though ## [1] &quot;11.500000&quot; &quot;11.300000&quot; &quot;11.800000&quot; &quot;11.900000&quot; &quot;12.300000&quot; 11.3.2.1.1 Anonymous functions In the former example, I did specify the function beforehand. map() also allows you to define the function within the call using a so-called anonymous function. The function’s argument is .x which stands for the respective input. map_dbl(example_dbl, ~{ .x + 10 }) ## [1] 11.5 11.3 11.8 11.9 12.3 The for loop which calculated the mean for the cars_tbl would have looked like this in purrr: map(cars_tbl, mean) ## $mpg ## [1] 20.09062 ## ## $cyl ## [1] 6.1875 ## ## $disp ## [1] 230.7219 ## ## $hp ## [1] 146.6875 ## ## $gear ## [1] 3.6875 When I put it into a tibble, names are preserved: map_dfc(cars_tbl, mean) ## # A tibble: 1 × 5 ## mpg cyl disp hp gear ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 20.1 6.19 231. 147. 3.69 11.3.2.2 Mapping over multiple arguments Sometimes you want to apply things to multiple arguments. Think for example of the sample()function. It requires at least two arguments: the size of the sample you draw and the element space x you draw the sample from. map2(10, 1:5, sample, replace = TRUE) ## [[1]] ## [1] 5 ## ## [[2]] ## [1] 6 7 ## ## [[3]] ## [1] 3 3 7 ## ## [[4]] ## [1] 9 8 3 10 ## ## [[5]] ## [1] 6 7 2 5 5 However, the map2() functions do not provide you with the possibility to control the type of output you get. You can take care of this using flatten_*(). map2(10, 5, sample) %&gt;% flatten_dbl() ## [1] 9 3 8 10 7 If you provide it with a vector which is longer than 1, map2() will not perform the operation on every possible combination of the two vectors. Instead, it iterates over both vectors simultaneously, hence, the first iteration uses the first two values, the second iteration the second two values etc. map2(c(10, 5), c(5, 3), sample) ## [[1]] ## [1] 9 4 8 10 3 ## ## [[2]] ## [1] 2 3 1 If you want to map over more than two arguments, pmap() is the way to go. If you work with functions which need multiple values as arguments, you can store the vectors containing the respective values in a tibble. You should name the columns according to the function’s arguments. An example here is drawing numbers from a normal distribution – rnorm(). The function takes three arguments: n– the number of values to be drawn, mean, and sd. tibble( n = 10, mean = 1:10, sd = 0.5 ) %&gt;% pmap(rnorm) ## [[1]] ## [1] 1.0840927 1.1774841 0.9739474 0.9020327 0.6754651 0.4451164 1.4246371 ## [8] 1.0111813 1.4155703 0.3778561 ## ## [[2]] ## [1] 2.084513 2.336583 1.986862 1.904304 1.609047 3.029081 2.375251 2.912104 ## [9] 2.040030 1.684295 ## ## [[3]] ## [1] 2.243356 2.681950 3.113151 3.506845 3.126375 2.414026 3.334357 2.174950 ## [9] 2.817074 2.841941 ## ## [[4]] ## [1] 3.025877 4.460029 3.688564 3.832982 4.697574 4.318337 3.945784 4.256881 ## [9] 4.199636 4.831428 ## ## [[5]] ## [1] 5.137947 5.253136 5.173776 4.811381 5.048810 5.819372 4.562204 5.060880 ## [9] 5.681065 4.882689 ## ## [[6]] ## [1] 5.473309 5.565108 5.804936 5.576325 5.869680 5.792790 5.908475 6.203528 ## [9] 6.312317 6.839103 ## ## [[7]] ## [1] 6.965653 6.839580 7.735503 7.852165 7.021622 6.833671 6.088882 7.705631 ## [9] 6.581209 6.438119 ## ## [[8]] ## [1] 9.521883 8.117511 7.983371 6.633890 7.950105 8.488016 8.206934 8.456161 ## [9] 8.991866 8.584554 ## ## [[9]] ## [1] 8.745631 9.352090 8.900792 8.730965 7.572121 8.605177 9.243907 ## [8] 10.084016 9.250347 9.310105 ## ## [[10]] ## [1] 9.517048 10.081327 8.960881 10.242613 10.348384 10.092757 10.350367 ## [8] 10.155841 10.380231 10.921232 11.4 Further links Chapter about loops in Hands-on Programming with R On control flow A basic introduction to purrr::map The corresponding chapter in R4DS References "],["references.html", "Chapter 12 References", " Chapter 12 References "],["exercises.html", "Chapter 13 Exercises 13.1 Chapter 2 13.2 Chapter 3 13.3 Chapter 4 13.4 Chapter 5 13.5 Chapter 6 13.6 Chapter 7 13.7 Chapter 8 13.8 Chapter 9 13.9 Chapter 10 13.10 Chapter 11", " Chapter 13 Exercises 13.1 Chapter 2 Install R and RStudio. Set RStudio up as you wish to. Choose a nice pane layout and theme. Create an RStudio Project for this course. Set up RMarkdown. Write a short text on your expectations for this course. It should at least contain: a header, an image, an unordered list. Knit it to HTML and PDF. Bonus points for including references to papers you would recommend. Install and load the tidyverse package. Solution. Click to expand! Solution: install.packages(&quot;tidyverse&quot;) library(tidyverse) 13.2 Chapter 3 A farmer has 53323 chickens, 1334 cows, and 4323 horses. Store them in a vector. Name the elements. The animals have bred. There are now 75 per cent more chickens, 30 per cent more cows, and 50 per cent more horses. What is this in absolute numbers? Store the results in a new vector. Round up the results using the ceiling() function. The farmer has to pay the tax amount x for every 2000th animal of a certain breed. How many times x does she have to pay for each breed (use the floor() function)? For which breed does she have to pay the most (you can use the max() function for this)? Store the data from task 6 in a tibble. Name the columns breed, number_timepoint_1, number_timepoint_2, number of tax units. a.Which variable should be converted to a factor variable? What’s the difference in numbers between time point 1 and time point 2? Store the result in a vector named difference. Solution. Click to expand! #1 #a animals &lt;- c(chicken = 53323, cows = 1334, horses = 4323) #b bred_animals &lt;- ceiling(animals * c(1.75, 1.3, 1.5)) #c taxes &lt;- floor(bred_animals/2000) max(taxes) #2 animal_tibble &lt;- tibble( breed = names(animals), number_timepoint_1 = animals, number_timepoint_2 = bred_animals, `number of tax units` = taxes ) #a #breed #b difference &lt;- animal_tibble[[&quot;number_timepoint_2&quot;]] - animal_tibble[[&quot;number_timepoint_1&quot;]] 13.3 Chapter 4 Firstly, download and extract the zip file. Then… Read them in using the right functions. Specify the parameters properly. Hints can be found in hints.md. Each file should be stored in an object, names should correspond to the file names. Bring the data sets into a tidy format. Store the tidy data sets in a new object, named like the former object plus the suffix \"_tidy\" – e.g., books_tidy. If no tidying is needed, you do not have to create a new object. The pipe operator should be used to connect the different steps. Note: this is challenging, absolutely. If you have problems, try to google the different functions and think about what the different parameters indicate. If that is to no avail, send me an e-mail. I am very happy to provide you further assistance. Solution. Click to expand! library(tidyverse) library(readxl) #read-in #books books &lt;- read_tsv(&quot;books.tsv&quot;) books &lt;- read_delim(&quot;books.txt&quot;, delim = &quot;|&quot;) #alternatively #ches ches_2017_tidy &lt;- read_csv(&quot;ches_2017.csv&quot;) ches_2017_modified &lt;- read_csv(&quot;ches_2017_modified.csv&quot;, skip = 4) #publishers publishers1 &lt;- read_excel(&quot;publishers.xlsx&quot;, sheet = &quot;publishers_a-l&quot;) publishers2 &lt;- read_excel(&quot;publishers.xlsx&quot;, sheet = &quot;publishers_m-z&quot;) %&gt;% rename(city = place) #spotify spotify2018 &lt;- read_csv(&quot;spotify2018.csv&quot;) #tidying #books books_tidy &lt;- read_delim(&quot;books.txt&quot;, delim = &quot;|&quot;) %&gt;% separate(col = &quot;author&quot;, into= c(&quot;author_1&quot;, &quot;author_2&quot;), sep = &quot; and &quot;) books_tidy_rows &lt;- read_delim(&quot;books.txt&quot;, delim = &quot;|&quot;) %&gt;% separate_rows(author, sep = c(&quot; and &quot;)) # There also is &quot; with &quot; as a potential separator -- separate() only takes a sep argument of length 1. You could replace &quot; with &quot; with &quot; and &quot; beforehand using `str_replace_all` -- but more on this in Chapter 6 books_really_tidy_rows &lt;- read_delim(&quot;books.txt&quot;, delim = &quot;|&quot;) %&gt;% mutate(author = str_replace_all(author, pattern = c(&quot; with &quot; = &quot; and &quot;))) %&gt;% separate_rows(author, sep = c(&quot; and &quot;)) #ches ches_2017_tidy &lt;- read_csv(&quot;ches_2017.csv&quot;) ches_2017_modified_tidy &lt;- read_csv(&quot;ches_2017_modified.csv&quot;, skip = 4) %&gt;% pivot_wider(names_from = variable) #publishers publishers1 &lt;- read_excel(&quot;publishers.xlsx&quot;, sheet = &quot;publishers_a-l&quot;) publishers2 &lt;- read_excel(&quot;publishers.xlsx&quot;, sheet = &quot;publishers_m-z&quot;) %&gt;% rename(city = place) publishers_tidy &lt;- bind_rows(publishers1, publishers2) %&gt;% separate(col = city, into = c(&quot;city&quot;, &quot;state&quot;), sep=&quot;, &quot;) #spotify spotify2018 &lt;- read_csv(&quot;spotify2018.csv&quot;) 13.4 Chapter 5 Open the IMDb file. Find the duplicated movie. How could you go across this? Which director has made the longest movie? What’s the highest ranked movie? Which movie got the most votes? Which movie had the biggest revenue in 2016? How much revenue did the movies in the dataset make each year in total? Filter movies following some conditions: More runtime than the average runtime (hint: you could also use mutate() before). Movies directed by J. J. Abrams. More votes than the median of all of the votes. The movies which have the most common value (the mode) in terms of rating (mode() does exist but will not work in the way you might like it to work – run the script below and use the my_mode function). ## helper function for mode my_mode &lt;- function(x){ ta = table(x) tam = max(ta) if (all(ta == tam)) mod = NA else if(is.numeric(x)) mod = as.numeric(names(ta)[ta == tam]) else mod = names(ta)[ta == tam] return(mod) } Solution. Click to expand! imdb &lt;- read_csv(&quot;imdb2006-2016.csv&quot;) #1 imdb %&gt;% count(Title) %&gt;% arrange(-n) #2 imdb %&gt;% arrange(-`Runtime (Minutes)`) %&gt;% slice(1) %&gt;% select(Director) #3 imdb %&gt;% arrange(Rank) %&gt;% slice(1) %&gt;% select(Title) #4 imdb %&gt;% arrange(-Votes) %&gt;% slice(1) %&gt;% select(Title) #5 imdb %&gt;% filter(Year == 2016) %&gt;% arrange(-`Revenue (Millions)`) %&gt;% slice(1) %&gt;% select(Title) #6 imdb %&gt;% filter(!is.na(`Revenue (Millions)`)) %&gt;% group_by(Year) %&gt;% summarize(total_revenue = sum(`Revenue (Millions)`)) #7a imdb %&gt;% filter(`Runtime (Minutes)` &gt; mean(`Runtime (Minutes)`)) #7b imdb %&gt;% filter(Director == &quot;J.J. Abrams&quot;) #7c imdb %&gt;% filter(Votes &gt; median(Votes)) #7d ## helper function for mode my_mode &lt;- function(x){ ta = table(x) tam = max(ta) if (all(ta == tam)) mod = NA else if(is.numeric(x)) mod = as.numeric(names(ta)[ta == tam]) else mod = names(ta)[ta == tam] return(mod) } imdb %&gt;% filter(Rating == my_mode(Rating)) 13.5 Chapter 6 1.Write a regex for Swedish mobile number. Test it with str_detect(\"+46 71-738 25 33\", \"[insert your regex here]\"). 2. There are different character classes. Write the regex expression for the character classes alnum (letters and numbers), alpha (letters), digit (digits), lower (lowercase letters), upper (uppercase letters), and space (different sorts of whitespace). 3. Remember the vector of heights? a. How can you extract the meters using the negative look behind? b. Bring it into numeric format (i.e., your_solution == c(1.3, 2.01, 3.1)) using regexes and stringr commands. 4. Find all Mercedes in the mtcars data set. 5. Take the IMDb file and split the Genre column into different columns (hint: look at the tidyr::separate() function). How would you do it if Genre were a vector using str_split_fixed()? Solution. Click to expand! #1 str_detect(&quot;+46 71-738 25 33&quot;, &quot;\\\\+46 [0-9]{2}\\\\-[0-9]{3} [0-9]{2} [0-9]{2}&quot;) #2 #3 heights &lt;- c(&quot;1m30cm&quot;, &quot;2m01cm&quot;, &quot;3m10cm&quot;) #a meters &lt;- str_extract(heights, &quot;(?&lt;!m)[0-9]&quot;) #b for_test &lt;- str_replace(heights, &quot;(?&lt;=[0-9])m&quot;, &quot;\\\\.&quot;) %&gt;% str_replace(&quot;cm&quot;, &quot;&quot;) %&gt;% as.numeric() for_test == c(1.3, 2.01, 3.1) #4 mtcars %&gt;% rownames_to_column(&quot;model&quot;) %&gt;% filter(str_detect(model, &quot;Merc&quot;)) #5 imdb &lt;- read_csv(&quot;imdb2006-2016.csv&quot;) imdb %&gt;% separate(Genre, sep = &quot;,&quot;, into = c(&quot;genre_1&quot;, &quot;genre_2&quot;, &quot;genre_3&quot;)) imdb$Genre %&gt;% str_split_fixed(pattern = &quot;,&quot;, 3) 13.6 Chapter 7 For now, I will not include too many exercises in here. However, you will have to work with factors extensively when we come to data visualization. Read in the ESS file. Convert the variable party_vote into a factor variable called party_code_fct. Drop all other variables. Look at the distribution of the parties; keep the 4 most common ones, all others should be coded to Other. Do it using the following three functions. Which of them was the best for the job? using fct_recode() using fct_collapse() using fct_lump() Reorder the factor levels according to their number of occurrence. Solution. Click to expand! #read file ess_2016 &lt;- read_csv(&quot;ess2016_ger.csv&quot;) #1 ess_w_factor &lt;- ess_2016 %&gt;% mutate(party_code_fct = as_factor(party_vote)) %&gt;% select(party_code_fct) #2 ess_w_factor %&gt;% count(party_code_fct) %&gt;% filter(!is.na(party_code_fct)) %&gt;% arrange(-n) #2a ess_recoded &lt;- ess_w_factor %&gt;% mutate(party_code_fct = fct_recode(party_code_fct, Other = &quot;AfD&quot;, Other = &quot;FDP&quot;, Other = &quot;Andere Partei&quot;, Other = &quot;Piratenpartei&quot;, Other = &quot;NPD&quot;)) # levels(ess_recoded$party_code_fct) # for validating that it has worked #2b ess_collapsed &lt;- ess_w_factor %&gt;% mutate(party_code_fct = fct_collapse(party_code_fct, Other = c(&quot;AfD&quot;, &quot;FDP&quot;, &quot;Andere Partei&quot;, &quot;Piratenpartei&quot;, &quot;NPD&quot;))) # levels(ess_collapsed$party_code_fct) # for validating that it has worked #2c ess_lumped &lt;- ess_w_factor %&gt;% mutate(party_code_fct = fct_lump(party_code_fct, n = 4)) # levels(ess_collapsed$party_code_fct) # for validating that it has worked #3 ess_ordered &lt;- ess_w_factor %&gt;% count(party_code_fct) %&gt;% mutate(party_code_fct = fct_reorder(party_code_fct, n)) # levels(ess_ordered$party_code_fct) # for validating that it has worked 13.7 Chapter 8 Take the IMDb file. Create a descriptive tibble containing the numeric variables which is sort of publishable (i.e., so that you could put it into a flextable or kable call). No need to discuss the results though. Does it make sense to use the arithmetic mean? Calculate the median and include it in the results for the numeric variables. Solution. Click to expand! library(skimr) imdb &lt;- read_csv(&quot;imdb2006-2016.csv&quot;) #1 for_table &lt;- imdb %&gt;% skim() %&gt;% yank(&quot;numeric&quot;) %&gt;% select(Variable = 1, Mean = 4, SD = 5, Minimum = 6, Maximum = 10) %&gt;% mutate(across(where(is.numeric), ~round(., 1))) #2 median_joined &lt;- imdb %&gt;% summarize(across(where(is.numeric), median, na.rm = TRUE)) %&gt;% pivot_longer( cols = everything(), names_to = c(&quot;Variable&quot;) ) %&gt;% mutate(value = round(value, 1)) %&gt;% rename(Median = value) %&gt;% right_join(for_table) 13.8 Chapter 9 Take the IMDb file. Try to think about how you could answer the following questions graphically. If you fail, take a look at the hints. Do higher rated movies generate more revenue? Plot revenue and rating as a scatter plot. Do you think there is a correlation? How could you make stronger claims about it? Maybe even graphically? Interpret the plot. Add a nice title and labels. How evenly are the different years’ movies represented? (Why would it be pointless to make claims about the productivity of directors?) Make a bar plot. Interpret the plot. Add a nice title and labels. Which year was the best for cinema fetishists? (When could they watch the most highest rated movies?) Make a box plot. Interpret the plot. Add a nice title and labels. Solution. Click to expand! imdb &lt;- read_csv(&quot;imdb2006-2016.csv&quot;) #1 imdb %&gt;% ggplot() + geom_point(aes(Rating, `Revenue (Millions)`)) + geom_smooth(aes(Rating, `Revenue (Millions)`), method = &quot;lm&quot;, se = FALSE) + labs(title = &quot;Fig. 1: Rating and Revenue; scatter plot with regression line&quot;) #2 imdb %&gt;% ggplot() + geom_bar(aes(x = Year)) + scale_x_continuous(breaks = 2006:2016) + labs(y = &quot;N&quot;, title = &quot;Fig. 2: Number of movies in the IMDb data set per year &quot;) #Not evenly at all! #It, of course, wouldn&#39;t make sense because we&#39;re only having a sample of the data here. #3 imdb %&gt;% ggplot() + geom_boxplot(aes(x = as_factor(Year), y = Rating)) + labs(title = &quot;Fig. 3: Boxplots depicting the movies&#39; rating&quot;, x = &quot;Year&quot;) 13.9 Chapter 10 No exercises for RMarkdown. If you want to, you can try to write the next report you have to hand in or something similar in RMarkdown. Hit me up for help and feedback whenever. 13.10 Chapter 11 Create a new vector of type character and length 3. Try to fill it with “I” “accomplished” “task2” using a for loop. Create proper names for the output of the following chunk (i.e., so that the last two columns’ names begin with “mean_”). using a for loop. using map and an anonymous function. summarize_mean &lt;- function(data, vars) { data %&gt;% summarize(n = n(), across({{ vars }}, mean)) } means_tbl &lt;- mtcars %&gt;% group_by(cyl) %&gt;% summarize_mean(all_of(c(&quot;hp&quot;, &quot;mpg&quot;))) %&gt;% glimpse() Use a for loop to compute the median of every numeric column in mtcars. Store it in a vector called median_values. Every element should have the name of the variable and the prefix median_. Try to store the results of the following pmap() call in a tibble. First call is in first column, second one in the second one, etc. How could you go across this? Create a rescale0to1 function. Play 10 rounds of Roulette and store the results in a tibble using a for loop using a while loop using map() (e.g., by storing them in a vector and then calling enframe()) Extend the Roulette function (colors!). You will need a lot of if…else. Try to split it up into functions (e.g., determine_color). Make it “bullet-proof” – how should you go across cases where people bet on a number and a color? You can use the following code chunk to determine the values and their colors: black &lt;- c(seq(2, 10, by = 2), seq(20, 28, by = 2), seq(11, 18, by = 2), seq(29, 36, by = 2)) red &lt;- seq(1, 36)[!(1:36) %in% black] green &lt;- 0 Solution. Click to expand! #1 raw_vec &lt;- c(&quot;I&quot;, &quot;accomplished&quot;, &quot;task3&quot;) fill_vec &lt;- character(length = 3L) for (i in seq_along(raw_vec)) { fill_vec[i] &lt;- raw_vec[i] } #2 #a for (i in 3:4) { colnames(means_tbl)[i] &lt;- str_c(&quot;mean_&quot;, colnames(means_tbl)[i]) } #b colnames(means_tbl)[3:4] &lt;- map_chr(colnames(means_tbl)[3:4], ~str_c(&quot;mean_&quot;, .x)) #3 median_values &lt;- numeric(length = 11L) for (i in seq_along(mtcars)) { median_values[i] &lt;- median(mtcars[ ,i], na.rm = TRUE) } set_names(median_values, str_c(&quot;median_&quot;, colnames(mtcars))) #4 tibble( n = 10, mean = 1:10, sd = 0.5 ) %&gt;% pmap(rnorm) %&gt;% bind_cols() #5 rescale0to1 &lt;- function(x) { (x - min(x, na.rm = TRUE)) / (max(x, na.rm = TRUE) - min(x. na.rm = TRUE)) } #6 play_roulette_basic &lt;- function(bet = 1, number) { if (number &gt; 36) stop(&quot;You can only bet on numbers between 0 and 36.&quot;) draw &lt;- sample(0:36, 1) if (number == draw) { return(str_c(&quot;Nice, you won&quot;, as.character(bet * 36), &quot;Dollars&quot;, sep = &quot; &quot;)) } else { return(&quot;I&#39;m sorry, you lost.&quot;) } } #a results_tbl_for &lt;- tibble( result = character(length = 10) ) for (i in seq_along(results_vec)) { results_tbl_for$result[[i]] &lt;- play_roulette_basic(1, 1) } #b results_tbl_while &lt;- tibble( result = character(length = 10) ) indicator &lt;- 0 while (indicator &lt; 10) { indicator &lt;- indicator + 1 results_tbl_while$result[[indicator]] &lt;- play_roulette_basic(1, 1) } #c results_tbl_map &lt;- map_chr(1:10, play_roulette_basic, n = 1) %&gt;% enframe(name = NULL, value = &quot;result&quot;) #7 to be done later determine_color &lt;- function(draw){ black &lt;- c(seq(2, 10, by = 2), seq(20, 28, by = 2), seq(11, 18, by = 2), seq(29, 36, by = 2)) red &lt;- seq(1, 36)[!(1:36) %in% black] green &lt;- 0 if (draw %in% black) return(&quot;black&quot;) if (draw %in% red) return(&quot;red&quot;) if (draw %in% green) return(&quot;green&quot;) } play_roulette &lt;- function(bet = 1, number = NA, color = NA) { if (number &gt; 36 &amp; is.na(number) == FALSE) stop(&quot;You can only bet on numbers between 0 and 36.&quot;) if (!color %in% c(&quot;green&quot;, &quot;red&quot;, &quot;black&quot;) &amp; is.na(color) == FALSE) stop(&quot;You can only bet on certain colors&quot;) if (is.na(color) == FALSE &amp; is.na(number) == FALSE) stop(&quot;You can either bet on numbers or colors.&quot;) if(is.na(color)) color &lt;- &quot;not applicable&quot; if(is.na(number)) number &lt;- &quot;not applicable&quot; draw &lt;- sample(0:36, 1) color_draw &lt;- determine_color(draw) if (color == color_draw) return(str_c(&quot;Nice, you won&quot;, as.character(bet * 2), &quot;Dollars&quot;, sep = &quot; &quot;)) if (number == draw) return(str_c(&quot;Nice, you won&quot;, as.character(bet * 36), &quot;Dollars&quot;, sep = &quot; &quot;)) return(&quot;Sorry, you lost.&quot;) } play_roulette(color = &quot;green&quot;) "]]
